import type { Task, DependencyDefinition } from "./CollectedState.js";
import type {
  PackageKind,
  ConduPackageEntry,
  PackageJsonModifier,
} from "./ConduPackageEntry.js";
import type { GlobalFileFlags } from "./GlobalFileFlags.js";
import type { PeerContext } from "./PeerContext.js";
import type {
  DefinedFileNames,
  FallbackFileNames,
  FallbackFileNameToDeserializedTypeMapping,
  GenerateFileOptions,
  ModifyGeneratedFileOptions,
  ModifyUserEditableFileOptions,
  ResolvedSerializedType,
} from "./FileManager.js";
import type { ConduProject } from "./ConduProject.js";

export interface ConduApi {
  // TODO: add error / warning functions
  readonly project: ReadonlyProject;
  readonly root: StateDeclarationApi;
  readonly packages: readonly ConduPackageEntry[];
  with(criteria: PackageFilterCriteria): StateDeclarationApi;
}

export type ReadonlyProject = Omit<ConduProject, "applyAndCommit">;

export interface PackageFilterCriteria {
  name?: string;
  kind?: PackageKind;
}

export interface StateDeclarationApi {
  ignoreFile(path: string, options?: GlobalFileFlags): void;
  generateFile<PathT extends string>(
    path: PathT,
    options: GenerateFileOptions<ResolvedSerializedType<PathT>>,
  ): void;
  modifyGeneratedFile<PathT extends string>(
    path: PathT,
    options: ModifyGeneratedFileOptions<ResolvedSerializedType<PathT>>,
  ): void;
  modifyUserEditableFile<
    PathT extends string,
    DeserializedT = PathT extends FallbackFileNames
      ? FallbackFileNameToDeserializedTypeMapping[PathT]
      : // if no deserializer is defined, we just pass the raw content
        string,
  >(
    path: PathT,
    options: (PathT extends DefinedFileNames
      ? "Error: This file is being generated by Condu. Use modifyGeneratedFile instead."
      : {}) &
      ModifyUserEditableFileOptions<DeserializedT>,
  ): void;
  addManagedDependency(dependency: DependencyDefinition): void;
  setDependencyResolutions(resolutions: Record<string, string>): void;
  modifyPackageJson(modifier: PackageJsonModifier): void;
  modifyPublishedPackageJson(modifier: PackageJsonModifier): void;
  defineTask(taskDefinition: Task): void;
}

// Define PeerContextReducer
export type PeerContextReducer = {
  readonly [K in keyof PeerContext]?: (
    current: PeerContext[K],
  ) => PeerContext[K] | Promise<PeerContext[K]>;
};

export type GetPeerContext<NameT extends keyof PeerContext | (string & {})> =
  NameT extends keyof PeerContext ? PeerContext[NameT] : never;

// Define the FeatureDefinition interface for the new API
export type FeatureDefinition<
  NameT extends keyof PeerContext | (string & {}) =
    | keyof PeerContext
    | (string & {}),
> = {
  name: NameT;
  // todo should this allow regex for dynamically created features?
  after?: Array<string> | string;
  mergePeerContext?: (
    project: ConduProject,
  ) => Promise<PeerContextReducer> | PeerContextReducer;
  defineRecipe: (
    condu: ConduApi,
    peerContext: GetPeerContext<NameT>,
  ) => void | Promise<void>;
} & (NameT extends keyof PeerContext
  ? {
      initialPeerContext:
        | GetPeerContext<NameT>
        | ((
            project: ConduProject,
          ) => GetPeerContext<NameT> | Promise<GetPeerContext<NameT>>);
    }
  : {});
