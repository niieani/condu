import type { Task, DependencyDefinitionInput } from "./CollectedState.js";
import type {
  PackageJsonModifier,
  ReadonlyConduPackageEntry,
  MatchPackage,
} from "./ConduPackageEntry.js";
import type { PeerContext } from "../../../types/extendable.js";
import type {
  DefinedFileNames,
  FallbackFileNames,
  FallbackFileNameToDeserializedTypeMapping,
  GenerateFileOptionsForPath,
  ModifyGeneratedFileOptions,
  ModifyUserEditableFileOptions,
  PartialGlobalFileAttributes,
  ResolvedSerializedType,
} from "./FileManager.js";
import type { ConduProject } from "./ConduProject.js";

export interface ConduApi {
  // TODO: add error / warning collection functions
  readonly project: ReadonlyConduProject;
  readonly root: StateDeclarationApi;
  readonly in: (criteria: MatchPackage) => StateDeclarationApi;
}

export type ReadonlyConduProject = Omit<
  ConduProject,
  "applyAndCommit" | "allPackages" | "workspace" | "workspacePackages"
> & {
  readonly allPackages: readonly ReadonlyConduPackageEntry[];
  readonly workspace: ReadonlyConduPackageEntry<"workspace">;
  readonly workspacePackages: readonly ReadonlyConduPackageEntry<"package">[];
};

export interface StateDeclarationApi {
  ignoreFile(
    path: string,
    options?: Omit<PartialGlobalFileAttributes, "inAllPackages">,
  ): void;
  generateFile<PathT extends string>(
    path: PathT,
    options: GenerateFileOptionsForPath<PathT>,
  ): void;
  modifyGeneratedFile<PathT extends string>(
    path: PathT,
    options: ModifyGeneratedFileOptions<ResolvedSerializedType<PathT>>,
  ): void;
  modifyUserEditableFile<
    PathT extends string,
    DeserializedT = PathT extends FallbackFileNames
      ? FallbackFileNameToDeserializedTypeMapping[PathT]
      : // if no deserializer is defined, we just pass the raw content
        string,
  >(
    path: PathT,
    options: (PathT extends DefinedFileNames
      ? "Error: This file is being generated by Condu. Use modifyGeneratedFile instead."
      : {}) &
      ModifyUserEditableFileOptions<DeserializedT>,
  ): void;
  ensureDependency(name: string, dependency?: DependencyDefinitionInput): void;
  setDependencyResolutions(resolutions: Record<string, string>): void;
  modifyPackageJson(modifier: PackageJsonModifier): void;
  modifyPublishedPackageJson(modifier: PackageJsonModifier): void;
  defineTask(name: string, taskDefinition: Omit<Task, "name">): void;
}

export type PeerContextReducer = {
  readonly [K in keyof PeerContext]?: (
    current: PeerContext[K],
  ) => PeerContext[K] | Promise<PeerContext[K]>;
};

export type PossibleFeatureNames = keyof PeerContext | (string & {});

export type GetPeerContext<NameT extends PossibleFeatureNames> =
  NameT extends keyof PeerContext ? PeerContext[NameT] : never;

interface FeatureDefinitionInputBase<
  NameT extends PossibleFeatureNames = keyof PeerContext | (string & {}),
> {
  // todo should this allow regex for dynamically created features?
  after?: Array<string> | string;
  modifyPeerContexts?: (
    project: ReadonlyConduProject,
    initialPeerContext: GetPeerContext<NameT>,
  ) => Promise<PeerContextReducer> | PeerContextReducer;
  defineRecipe: (
    condu: ConduApi,
    peerContext: GetPeerContext<NameT>,
  ) => void | Promise<void>;
}

type WithInitialPeerContext<NameT extends PossibleFeatureNames> =
  NameT extends keyof PeerContext
    ? {
        initialPeerContext:
          | GetPeerContext<NameT>
          | ((
              project: ReadonlyConduProject,
            ) => GetPeerContext<NameT> | Promise<GetPeerContext<NameT>>);
      }
    : {};

export type FeatureDefinitionInput<
  NameT extends PossibleFeatureNames = keyof PeerContext | (string & {}),
> = FeatureDefinitionInputBase<NameT> & WithInitialPeerContext<NameT>;

export type FeatureDefinition<
  NameT extends PossibleFeatureNames = PossibleFeatureNames,
> = FeatureDefinitionInput<NameT> & {
  name: NameT;
  // TODO: maybe instead of stack just the file path of the feature definition from import.meta.url?
  stack: string;
};

export type FeatureActionFn = <NameT extends keyof PeerContext | (string & {})>(
  name: NameT,
  definition: FeatureDefinitionInput<NameT>,
) => FeatureDefinition<NameT>;
