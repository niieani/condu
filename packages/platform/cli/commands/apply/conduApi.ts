import type { Task, DependencyDefinition } from "./CollectedState.js";
import type {
  PackageJsonModifier,
  ReadonlyConduPackageEntry,
  MatchPackage,
} from "./ConduPackageEntry.js";
import type {
  GlobalFileFlags,
  GlobalPeerContext,
} from "@condu/types/extendable.js";
import type { PeerContext } from "../../../types/extendable.js";
import type {
  DefinedFileNames,
  FallbackFileNames,
  FallbackFileNameToDeserializedTypeMapping,
  GenerateFileOptionsForPath,
  ModifyGeneratedFileOptions,
  ModifyUserEditableFileOptions,
  ResolvedSerializedType,
} from "./FileManager.js";
import type { ConduProject } from "./ConduProject.js";

export interface ConduApi {
  // TODO: add error / warning collection functions
  readonly project: ReadonlyConduProject;
  readonly inRoot: StateDeclarationApi;
  readonly in: (criteria: MatchPackage) => StateDeclarationApi;
}

export type ReadonlyConduProject = Omit<
  ConduProject,
  "applyAndCommit" | "allPackages" | "workspace" | "workspacePackages"
> & {
  readonly allPackages: readonly ReadonlyConduPackageEntry[];
  readonly workspace: ReadonlyConduPackageEntry<"workspace">;
  readonly workspacePackages: readonly ReadonlyConduPackageEntry<"package">[];
};

export interface StateDeclarationApi {
  ignoreFile(path: string, options?: GlobalFileFlags): void;
  generateFile<PathT extends string>(
    path: PathT,
    options: GenerateFileOptionsForPath<PathT>,
  ): void;
  modifyGeneratedFile<PathT extends string>(
    path: PathT,
    options: ModifyGeneratedFileOptions<ResolvedSerializedType<PathT>>,
  ): void;
  modifyUserEditableFile<
    PathT extends string,
    DeserializedT = PathT extends FallbackFileNames
      ? FallbackFileNameToDeserializedTypeMapping[PathT]
      : // if no deserializer is defined, we just pass the raw content
        string,
  >(
    path: PathT,
    options: (PathT extends DefinedFileNames
      ? "Error: This file is being generated by Condu. Use modifyGeneratedFile instead."
      : {}) &
      ModifyUserEditableFileOptions<DeserializedT>,
  ): void;
  addManagedDependency(dependency: DependencyDefinition): void;
  setDependencyResolutions(resolutions: Record<string, string>): void;
  modifyPackageJson(modifier: PackageJsonModifier): void;
  modifyPublishedPackageJson(modifier: PackageJsonModifier): void;
  defineTask(taskDefinition: Task): void;
}

export type PeerContextReducer = {
  readonly [K in keyof PeerContext]?: (
    current: PeerContext[K],
  ) => PeerContext[K] | Promise<PeerContext[K]>;
};

export type GetPeerContext<NameT extends keyof PeerContext | (string & {})> =
  NameT extends keyof PeerContext ? PeerContext[NameT] : never;

// Define the FeatureDefinition interface for the new API
export type FeatureDefinition<
  NameT extends keyof PeerContext | (string & {}) =
    | keyof PeerContext
    | (string & {}),
> = {
  name: NameT;
  // todo should this allow regex for dynamically created features?
  after?: Array<string> | string;
  modifyPeerContexts?: (
    project: ReadonlyConduProject,
    initialPeerContext: GetPeerContext<NameT>,
  ) => Promise<PeerContextReducer> | PeerContextReducer;
  defineRecipe: (
    register: ConduApi,
    peerContext: GetPeerContext<NameT>,
  ) => void | Promise<void>;
} & (NameT extends keyof PeerContext
  ? {
      initialPeerContext:
        | GetPeerContext<NameT>
        | ((
            project: ReadonlyConduProject,
          ) => GetPeerContext<NameT> | Promise<GetPeerContext<NameT>>);
    }
  : {});
