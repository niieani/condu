import {
  SymlinkTarget,
  type ConduConfigWithInferredValuesAndProject,
  type ConduPackageJson,
  type WorkspacePackage,
} from "@condu/types/configTypes.js";
import {
  write,
  type WrittenFile,
} from "@condu/cli/commands/apply/readWrite.js";
import path from "node:path";
import { match, P } from "ts-pattern";
import { stringify as yamlStringify, parse as yamlParse } from "yaml";
import {
  stringify as commentJsonStringify,
  parse as commentJsonParse,
} from "comment-json";
import fs from "node:fs/promises";
import { printUnifiedDiff } from "print-diff";
import readline from "node:readline/promises";

// Define PeerContext as an empty interface to be extended via declaration merging
export interface PeerContext {
  // TODO: maybe we move as much of functionality into condu context that's always there?
  condu: { _: string };
}

// Define PeerContextReducer
export type PeerContextReducer = {
  readonly [K in keyof PeerContext]?: (
    current: PeerContext[K],
  ) => PeerContext[K] | Promise<PeerContext[K]>;
};

export type GetPeerContext<NameT extends keyof PeerContext | (string & {})> =
  NameT extends keyof PeerContext ? PeerContext[NameT] : never;

// Define the FeatureDefinition interface for the new API
export type FeatureDefinition<
  NameT extends keyof PeerContext | (string & {}) =
    | keyof PeerContext
    | (string & {}),
> = {
  name: NameT;
  // todo should this allow regex for dynamically created features?
  after?: Array<string> | string;
  mergePeerContext?: (
    config: ConduConfigWithInferredValuesAndProject,
  ) => Promise<PeerContextReducer> | PeerContextReducer;
  apply: (
    condu: Condu,
    peerContext: GetPeerContext<NameT>,
  ) => void | Promise<void>;
} & (NameT extends keyof PeerContext
  ? { initialPeerContext: GetPeerContext<NameT> }
  : {});

export interface Condu {
  config: ConduConfigWithInferredValuesAndProject;
  root: PackageCondu;
  with(criteria: PackageCriteria): PackageCondu;
  packages: WorkspacePackage[];
}

type JsonFileName = `${string}.${"json" | "jsonc" | "json5"}`;
type YamlFileName = `${string}.${"yaml" | "yml"}`;

// a public interface that can be extended by features to include additional file types
// all these need to be created using generateFile call with a parse and stringify method
export interface FileNameToSerializedTypeMapping {
  ".gitignore": Array<string>;
  "package.json": ConduPackageJson;
}

export interface FallbackFileNameToDeserializedTypeMapping {
  [file: JsonFileName]: object;
  [file: YamlFileName]: object;
}

// another public interface that can be extended by features
export interface GlobalFileFlags {
  gitignore?: boolean;
  npmignore?: boolean;
}

type DefinedFileNames = keyof FileNameToSerializedTypeMapping;
type FallbackFileNames = keyof FallbackFileNameToDeserializedTypeMapping;
type PossibleDeserializedValue = object | string | number | boolean | null;

export type ResolvedSerializedType<PathT extends string> =
  PathT extends DefinedFileNames
    ? FileNameToSerializedTypeMapping[PathT]
    : PathT extends FallbackFileNames
      ? FallbackFileNameToDeserializedTypeMapping[PathT]
      : string;

export interface PackageCondu {
  ignoreFile(path: string, options?: GlobalFileFlags): void;
  generateFile<PathT extends string>(
    path: PathT,
    options: GenerateFileOptions<ResolvedSerializedType<PathT>>,
  ): void;
  modifyGeneratedFile<PathT extends string>(
    path: PathT,
    options: ModifyGeneratedFileOptions<ResolvedSerializedType<PathT>>,
  ): void;
  modifyUserEditableFile<
    PathT extends string,
    DeserializedT = PathT extends FallbackFileNames
      ? FallbackFileNameToDeserializedTypeMapping[PathT]
      : // if no deserializer is defined, we just pass the raw content
        string,
  >(
    path: PathT,
    options: (PathT extends DefinedFileNames
      ? "Error: This file is being generated by Condu. Use modifyGeneratedFile instead."
      : {}) &
      ModifyUserEditableFileOptions<DeserializedT>,
  ): void;
  addManagedDevDependency(dependency: string): void;
  addManagedDependency(dependency: string): void;
  setDependencyResolutions(resolutions: Record<string, string>): void;
  mergePackageJson(modifier: (pkg: ConduPackageJson) => ConduPackageJson): void;
  mergeReleasePackageJson(
    modifier: (pkg: ConduPackageJson) => ConduPackageJson,
  ): void;
}

type IfPreviouslyDefined = "error" | "overwrite";

// Define options interfaces
export interface GenerateFileOptions<DeserializedT> extends GlobalFileFlags {
  content:
    | DeserializedT
    | ((pkg: ConduPackageJson) => DeserializedT | Promise<DeserializedT>);

  /** defaults to stringify based on file extension */
  stringify?: (content: DeserializedT) => string;

  /** defaults to 'error' */
  ifPreviouslyDefined?: IfPreviouslyDefined;
}

type IfNotCreated = "ignore" | "error" | "create";

export interface ModifyOnlyGeneratedFileOptions<DeserializedT>
  extends GlobalFileFlags {
  content: (
    content: DeserializedT,
    pkg: ConduPackageJson,
  ) => DeserializedT | Promise<DeserializedT>;
  // default is "ignore"
  ifNotCreated?: Exclude<IfNotCreated, "create">;
}

export interface ModifyOrCreateGeneratedFileOptions<DeserializedT>
  extends GlobalFileFlags {
  content: (
    content: DeserializedT | undefined,
    pkg: ConduPackageJson,
  ) => DeserializedT | Promise<DeserializedT>;

  // for now we can not support 'create' here for simplicity
  ifNotCreated: "create";

  /** defaults to stringify based on file extension */
  stringify?: (content: DeserializedT) => string;
}

export type ModifyGeneratedFileOptions<DeserializedT> =
  | ModifyOnlyGeneratedFileOptions<DeserializedT>
  | ModifyOrCreateGeneratedFileOptions<DeserializedT>;

export type ModifyUserEditableFileOptions<DeserializedT> =
  | ModifyUserEditableFileOptionsWithBuiltinSerialization<DeserializedT>
  | ModifyUserEditableFileOptionsWithCustomSerialization<DeserializedT>;

export interface ModifyUserEditableFileOptionsWithBuiltinSerialization<
  DeserializedT,
> extends GlobalFileFlags {
  // default is true, in which case content signature can include content: undefined
  createIfNotExists?: boolean;
  content: (
    content: DeserializedT | undefined,
    pkg: ConduPackageJson,
  ) => DeserializedT | Promise<DeserializedT>;

  // parse and stringify must exist with a `never` type to make it exact
  // otherwise TS will not discriminate the union correctly
  // by default uses 'json-comment' for .json files, and 'yaml' for .yaml files
  parse?: never;
  stringify?: never;
}

export interface ModifyUserEditableFileOptionsWithCustomSerialization<
  DeserializedT,
> extends GlobalFileFlags {
  createIfNotExists?: boolean;
  content: (
    content: DeserializedT | undefined,
    pkg: ConduPackageJson,
  ) => DeserializedT | Promise<DeserializedT>;

  parse: (rawFileContent: string) => DeserializedT;
  stringify: (content: DeserializedT) => string;
}

export interface PackageCriteria {
  name?: string;
  kind?: "workspace" | "package";
}

// Define types for collected changes
export interface ChangesCollector {
  ignoredFiles: CollectedIgnoreFileChange<string>[];
  generatedFiles: CollectedGenerateFileChange<string>[];
  generatedFilesModifications: CollectedModifyGeneratedFileChange<
    string,
    unknown
  >[];
  userEditableFilesModifications: CollectedModifyUserEditableFileChange<
    string,
    unknown
  >[];
  dependencies: CollectedDependency[];
  resolutions: Record<string, string>;
  packageJsonModifications: PackageJsonModification[];
  releasePackageJsonModifications: PackageJsonModification[];
}

// there needs to be another step to convert those to FileDef

export interface CollectedIgnoreFileChange<PathT extends string> {
  targetPackage: WorkspacePackage;
  path: PathT;
  rootRelativePath: string;
  options: GlobalFileFlags | undefined;
  changeType: "ignore";
}

export interface CollectedGenerateFileChange<PathT extends string> {
  targetPackage: WorkspacePackage;
  path: PathT;
  rootRelativePath: string;
  options: GenerateFileOptions<ResolvedSerializedType<PathT>>;
  changeType: "generate";
}

export interface CollectedModifyGeneratedFileChange<
  PathT extends string,
  DeserializedT,
> {
  targetPackage: WorkspacePackage;
  path: PathT;
  rootRelativePath: string;
  options: ModifyGeneratedFileOptions<DeserializedT>;
  changeType: "modifyGenerated";
}

export interface CollectedModifyUserEditableFileChange<
  PathT extends string,
  DeserializedT,
> {
  targetPackage: WorkspacePackage;
  path: PathT;
  rootRelativePath: string;
  options: ModifyUserEditableFileOptions<DeserializedT>;
  changeType: "modifyUserEditable";
}

export type CollectedFileChange<PathT extends string> =
  | CollectedIgnoreFileChange<PathT>
  | CollectedGenerateFileChange<PathT>
  | CollectedModifyGeneratedFileChange<PathT, unknown>
  | CollectedModifyUserEditableFileChange<PathT, unknown>;

export interface CollectionContext {
  featureName: string;
  // we can consider adding a stack trace here
}

export type ModifyUserEditableFileOptionsWithContext<
  DeserializedT extends PossibleDeserializedValue,
> = ModifyUserEditableFileOptions<DeserializedT> & {
  context: CollectionContext;
};

export type ModifyGeneratedFileOptionsWithContext<
  DeserializedT extends PossibleDeserializedValue,
> = ModifyGeneratedFileOptions<DeserializedT> & {
  context: CollectionContext;
};

export type FileKind =
  | "flags-only"
  | "generated"
  | "user-editable"
  | "symlink"
  | "invalid";

const keepRaw = <T>(value: T) => value;

export function getDefaultParse<DeserializedT>(
  filePath: string,
): (rawFileContent: string) => DeserializedT {
  const extension = path.extname(filePath);
  return match(extension)
    .with(P.string.regex(/\.ya?ml$/i), () => yamlParse)
    .with(
      P.string.regex(/\.json5?$/i),
      () => commentJsonParse as (raw: string) => DeserializedT,
    )
    .otherwise(() => keepRaw);
}

const jsonStringify = (content: unknown): string =>
  commentJsonStringify(content, undefined, 2);

export function getDefaultStringify<DeserializedT>(
  filePath: string,
): (content: DeserializedT) => string {
  const extension = path.extname(filePath);
  return match(extension)
    .with(P.string.regex(/\.ya?ml$/i), () => yamlStringify)
    .otherwise(() => jsonStringify);
}

const isInteractive =
  process.stdout.isTTY &&
  process.stdin.isTTY &&
  process.env["npm_lifecycle_event"] !== "postinstall";

export class FileProcessingPipeline<
  DeserializedT extends PossibleDeserializedValue,
> {
  path: string;
  // kind: "flags-only" | "generated" | "user-editable" | "symlink" = "flags-only";
  flags: GlobalFileFlags = {};
  targetPackage: WorkspacePackage;
  pipelineContextBreadcrumbs: CollectionContext[] = [];
  status: "pending" | "applied" | "ignored" = "pending";

  symlinkTarget?: string;
  initialContent?:
    | DeserializedT
    | ((pkg: ConduPackageJson) => DeserializedT | Promise<DeserializedT>);
  contentModifications: Array<
    ModifyGeneratedFileOptionsWithContext<DeserializedT>
  > = [];
  editableContentModifications: Array<
    ModifyUserEditableFileOptionsWithContext<DeserializedT>
  > = [];

  context: {
    absPath: string;
  };

  // defaults to stringify based on file extension
  stringify: (content: DeserializedT) => string;

  // TODO: path should be relative from repo root
  // move targetPackage out to addInitialContent/modification
  constructor(
    path: string,
    targetPackage: WorkspacePackage,
    flags: GlobalFileFlags,
  ) {
    this.path = path;
    this.flags = flags;
    // TODO: handle edge case - prevent reaching into other packages by using relative paths or from root (e.g. by specifiying root package + ./packages/file as the path)
    this.targetPackage = targetPackage;
    // set default stringify based on file name/extension
    this.stringify = getDefaultStringify(this.path);
  }

  private updateFlags(flags: GlobalFileFlags) {
    // only set the flags that are provided
    for (const [key, value] of Object.entries(flags)) {
      // flags can only be string, number or boolean
      if (
        typeof value === "string" ||
        typeof value === "number" ||
        typeof value === "boolean"
      ) {
        this.flags[key as keyof GlobalFileFlags] = value as NonNullable<
          GlobalFileFlags[keyof GlobalFileFlags]
        >;
      }
    }
  }

  updateIgnores(flags: GlobalFileFlags, context: CollectionContext) {
    this.pipelineContextBreadcrumbs.push(context);
    this.updateFlags(flags);
  }

  addInitialContent({
    content,
    stringify,
    context,
    ifPreviouslyDefined = "error",
    ...flags
  }: GenerateFileOptions<DeserializedT> & { context: CollectionContext }) {
    this.pipelineContextBreadcrumbs.push(context);
    this.updateFlags(flags);
    if (this.initialContent && ifPreviouslyDefined === "error") {
      // TODO: safe error handling instead of throwing
      throw new Error(`Initial content already set for file ${this.path}`);
    }
    this.initialContent = content;
    if (stringify) {
      this.stringify = stringify;
    }
  }

  addModification(
    modification: ModifyGeneratedFileOptionsWithContext<DeserializedT>,
  ) {
    const {
      content,
      context,
      // TODO: maybe a cleaner way to extract flags?
      ...flags
    } = modification;
    this.pipelineContextBreadcrumbs.push(context);
    this.updateFlags(flags);
    this.contentModifications.push(modification);
  }

  addUserEditableModification(
    modification: ModifyUserEditableFileOptionsWithContext<DeserializedT>,
  ) {
    // it's okay to allow modifications to generated files
    // because we can stringify and parse them
    // but it has to happen after all generated modifications

    // what about the opposite?
    // if (this.kind === 'generated') {
    //   throw new Error(`Cannot modify a generated file, use modifyGeneratedFile instead`);
    // }
    const {
      content,
      context,
      parse,
      stringify,
      createIfNotExists,
      // TODO: maybe a cleaner way to extract flags?
      ...flags
    } = modification;
    this.pipelineContextBreadcrumbs.push(context);
    this.updateFlags(flags);
    this.editableContentModifications.push(modification);

    // TODO: we should re-parse and re-stringify after each modification?
    // if (!this.parse) {
    //   this.parse = parse ?? getDefaultParse(this.path)
    // }
    // if (stringify) {
    //   this.stringify = stringify;
    // }
  }

  setSymlinkTarget(target: string) {
    this.symlinkTarget = target;
  }

  async applyAndCommit(): Promise<FileKind> {
    // depending on the kind:
    // reads the file content
    // parses the file content
    // applies the modifications
    // writes the file content

    if (this.symlinkTarget) {
      await this.writeToFileSystem(new SymlinkTarget(this.symlinkTarget));
      return "symlink";
    }

    let kind: FileKind = "flags-only";

    // move all modifications with createIfNotExists: false to the end
    this.editableContentModifications.sort((a, b) =>
      a.createIfNotExists === false
        ? 1
        : b.createIfNotExists === false
          ? -1
          : 0,
    );

    // move all modifications with ifNotCreated: "create" to the beginning
    this.contentModifications.sort((a, b) =>
      a.ifNotCreated === "create" ? -1 : b.ifNotCreated === "create" ? 1 : 0,
    );

    let content: DeserializedT | undefined =
      typeof this.initialContent === "function"
        ? await this.initialContent(this.targetPackage)
        : this.initialContent;

    let ifNotCreated: IfNotCreated = "ignore";

    // reduce the content to the final state
    for (const modification of this.contentModifications) {
      if (content === undefined && modification.ifNotCreated === "create") {
        // if no content, try the modification that can create the file
        content = await modification.content(undefined, this.targetPackage);
        if (modification.stringify) {
          this.stringify = modification.stringify;
        }
      } else {
        if (modification.ifNotCreated === "error") {
          ifNotCreated = "error";
        }
        if (content === undefined) {
          if (ifNotCreated === "error") {
            throw new Error(
              `Cannot generate ${this.path}, no initial content provided`,
            );
          }
          this.status = "ignored";
          // nothing to do, finish here
          return "invalid";
        }
        content = await modification.content(content, this.targetPackage);
      }
      // TODO: add debugging breadcrumbs for actually applied creations / modifications
    }

    if (content !== undefined) {
      // if by this point we got content, it's a generated file
      kind = "generated";
    }

    let stringified: string | undefined =
      content !== undefined ? this.stringify(content) : undefined;

    if (this.editableContentModifications.length > 0) {
      if (stringified) {
        // TODO: warn that we are editing a generated file, not a user-provided one
      }
      // user-editable files get parsed from the filesystem contents
      stringified = stringified ?? (await this.getContentFromFileSystem());
    }

    for (const modification of this.editableContentModifications) {
      const parse = modification.parse ?? getDefaultParse(this.path);
      content = stringified ? parse(stringified) : undefined;
      if (content === undefined) {
        if (modification.createIfNotExists === false) {
          throw new Error(
            `Cannot modify ${this.path}, no initial content provided`,
          );
        } else {
          this.status = "ignored";
          // nothing to do, finish here
          return "invalid";
        }
      }

      if (kind !== "generated") {
        kind = "user-editable";
      }

      // get the next version of the content:
      content = await modification.content(content, this.targetPackage);
      const stringify =
        modification.stringify ?? getDefaultStringify(this.path);
      stringified = stringify(content);
    }

    if (stringified) {
      await this.writeToFileSystem(stringified, kind === "user-editable");
    }

    this.status = "applied";

    return kind;
  }

  /**
   * the current file as is present in the FS
   * if the file was deleted, this will be "deleted"
   * if the fsState is the same as lastApply, this will be "unchanged"
   **/
  _fsState?: Omit<WrittenFile, "path"> | "deleted" | "unchanged";
  lastApply?: WrittenFile;

  async ensureFsState(): Promise<
    Omit<WrittenFile, "path"> | "deleted" | "unchanged"
  > {
    if (this._fsState) {
      return this._fsState;
    }
    const fullPath = path.join(this.context.absPath, this.path);
    const stat = await fs.lstat(fullPath).catch(() => undefined);
    const symlinkTarget = stat?.isSymbolicLink()
      ? await fs.readlink(fullPath).catch(() => undefined)
      : undefined;
    const content = symlinkTarget
      ? new SymlinkTarget(symlinkTarget)
      : await fs.readFile(fullPath, "utf-8").catch(() => undefined);

    if (!stat || content === undefined) {
      // TODO: rename to 'nonexistent'
      this._fsState = "deleted";
      return this._fsState;
    }

    if (this.lastApply?.content === content) {
      this._fsState = "unchanged";
      return this._fsState;
    }

    const modifiedAt = stat.mtimeMs;
    const size = stat.size;

    // TODO: maybe instead of SymlinkTarget, we have 'target' as a separate field?
    const fsState: Omit<WrittenFile, "path"> = {
      content,
      modifiedAt,
      size,
    };

    this._fsState = fsState;
    return fsState;
  }

  async getFsFile(): Promise<Omit<WrittenFile, "path"> | undefined> {
    const fsState = await this.ensureFsState();
    if (fsState === "unchanged") {
      // lastApply is guaranteed to be set here
      return this.lastApply!;
    }
    if (fsState === "deleted") {
      return undefined;
    }
    return fsState;
  }

  async getContentFromFileSystem(): Promise<string | undefined> {
    const file = await this.getFsFile();
    if (typeof file === "object" && typeof file.content === "string") {
      return file.content;
    }
    return undefined;
  }

  async writeToFileSystem(
    newContent: string | SymlinkTarget,
    overwriteWithoutAsking = false,
  ): Promise<(() => Promise<WrittenFile>) | WrittenFile | undefined> {
    // TODO
    // compare with the fs content
    // if different:
    // option to resolve conflicts
    // write to fs
    // TODO: update this._fsState (only if changes made)
    // TODO: update this.lastApply (only if changes made)
    // somewhere else: update cache
    const targetPath = path.join(this.context.absPath, this.path);

    const existingFile = await this.getFsFile();

    if (
      existingFile &&
      existingFile.content.toString().trim() === newContent.toString().trim()
    ) {
      // already up to date
      return existingFile;
    }

    if (newContent instanceof SymlinkTarget) {
      if (existingFile && existingFile.content instanceof SymlinkTarget) {
        // linked content mismatch, unlink the existing file
        // no need to ask for confirmation for symlinks
        console.log(`Unlinking: ${this.path}`);
        await fs.unlink(targetPath);
      }
      return write({
        targetPath,
        content: newContent,
        pathFromWorkspaceDirAbs: this.path,
      });
    }

    if (!existingFile || overwriteWithoutAsking) {
      // no existing file, or different content
      return write({
        targetPath,
        content: newContent,
        pathFromWorkspaceDirAbs: this.path,
      });
    } else if (!overwriteWithoutAsking) {
      console.warn(
        new Error(`Manual changes present in ${this.path}, cannot continue.`),
      );
      return undefined;
    } else {
      // return a function for interactive overwrite
      // this needs to happen sequentially, because we're prompting the user for input:
      return async () => {
        console.log(`Manual changes present in ${this.path}`);
        printUnifiedDiff(
          existingFile.content.toString(),
          newContent,
          process.stdout,
        );
        if (!isInteractive) {
          process.exitCode = 1;
          console.log(
            `Please resolve the conflict by running 'condu apply' interactively. Skipping: ${this.path}`,
          );
          return this.lastApply;
        }

        const rl = readline.createInterface({
          input: process.stdin,
          output: process.stdout,
        });
        const rawAnswer = await rl.question(
          "Do you want to overwrite the file? (y/n)",
        );
        rl.close();
        const shouldOverwrite = match(rawAnswer)
          .with(P.union("y", "Y", P.string.regex(/yes/i)), () => true)
          .otherwise(() => false);

        if (shouldOverwrite) {
          return write({
            targetPath,
            content: newContent,
            pathFromWorkspaceDirAbs: this.path,
          });
        } else {
          process.exitCode = 1;
          console.log(
            `Please update your config and re-run 'condu apply' when ready. Skipping: ${pathFromWorkspaceDirAbs}`,
          );
          return this.lastApply;
        }
      };
    }
  }

  // async updateSymlink(symlinkTarget: string): Promise<void> {
  //   const fsState = await this.getFsFile();
  //   if (typeof fsState === "object") {
  //     if (typeof fsState.content === "object") {
  //       if (fsState.content.target === symlinkTarget) {
  //         // nothing to do
  //         return;
  //       } else {
  //         // TODO: remove the symlink, will create a new one below
  //         // no need to ask for confirmation for symlinks
  //         console.log(`Unlinking: ${this.path}`);
  //         await fs.unlink(path.join(this.context.absPath, this.path));
  //       }
  //     } else {
  //       // TODO: warn that the file would be overwritten by a symlink
  //       // err on the side of caution
  //       console.warn(
  //         new Error(
  //           `Cannot create symlink for ${this.path}, file already exists`,
  //         ),
  //       );
  //       return;
  //     }
  //   }
  //   // TODO: write the symlink and update this._fsState
  //   const targetPath = path.join(this.context.absPath, this.path);
  //   await fs.symlink(symlinkTarget, targetPath);
  //   // this._fsState = {
  //   //   content: new SymlinkTarget(symlinkTarget),
  //   //   modifiedAt: Date.now(),
  //   //   size: 0,
  //   // };
  // }
}

export interface CollectedDependency {
  pkg: WorkspacePackage;
  dependency: string;
  type: "dev" | "prod";
}

export interface PackageJsonModification {
  pkg: WorkspacePackage;
  modifier: (pkg: ConduPackageJson) => ConduPackageJson;
}
