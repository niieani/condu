import type {
  ConduPackageEntry,
  WorkspaceSubPackage,
  WorkspaceRootPackage,
} from "../apply/ConduPackageEntry.js";
import * as fs from "node:fs/promises";
import { sortPackageJson } from "sort-package-json";
import * as path from "node:path";
import { copyFiles } from "@condu/core/utils/copy.js";
import spdxLicenseList from "spdx-license-list/full.js";
import { createExportableManifest } from "@pnpm/exportable-manifest";
import { readWorkspaceManifest } from "@pnpm/workspace.read-manifest";
import { getCatalogsFromWorkspaceManifest } from "@pnpm/catalogs.config";
import { partition } from "remeda";
import { getSingleMatch } from "../../matchPackage.js";
import { apply } from "../apply/apply.js";
import { topo } from "@condu/workspace-utils/topo.js";
import { spawn } from "node:child_process";
import { safelyParseLastJsonFromString } from "@condu/core/utils/safelyParseJsonFromString.js";
import type { ConduProject } from "../apply/ConduProject.js";
import { getPublishablePackageDirectory } from "./publishableDirectory.js";
import type { CollectedState } from "../apply/CollectedState.js";

const DECLARATION_FILE_EXT_REGEXP = /\.d\.[cm]?ts$/;
const TSCONFIG_LIKE_FILENAME_REGEXP = /tsconfig\..*\.json$/;

/**
 * Prepares the packages in 'build' directory for release:
 * - Copies non-JS files from packages to the 'build' directory.
 * - Ensures there is a LICENSE
 * - Fills in package.json fields.
 */
export async function prepareAndReleaseDirectoryPackages({
  workspaceDirAbs,
  packagesToPrepare,
  absBuildDir,
  srcDirName,
  buildDirName,
  project,
  collectedState,
  npmTag,
  dryRun,
}: {
  workspaceDirAbs: string;
  packagesToPrepare: readonly ConduPackageEntry[];
  absBuildDir: string;
  srcDirName: string;
  buildDirName: string;
  project: ConduProject;
  collectedState: CollectedState;
  npmTag?: string;
  dryRun?: boolean;
}) {
  // TODO: ensure we had run 'apply' before this, so that the cache has been populated

  const configFileAbsolutePaths = Array.from(
    collectedState.fileManager.files.keys(),
  ).map((filePath) => path.join(workspaceDirAbs, filePath));

  const pnpmWorkspaceManifest = await readWorkspaceManifest(project.absPath);
  const catalogs = getCatalogsFromWorkspaceManifest(pnpmWorkspaceManifest);

  const { queue } = topo(packagesToPrepare);
  const packagesToPrepareObj = Object.fromEntries(
    packagesToPrepare.map((pkg) => [pkg.name, pkg]),
  );

  for (const name of queue) {
    const pkg = packagesToPrepareObj[name]!;
    const { relPath: packageDir } = pkg;
    const packageBuildDir = path.join(absBuildDir, packageDir);
    const packageSourceDir = path.join(workspaceDirAbs, packageDir, srcDirName);
    console.log(`Copying ${packageDir} for ${pkg.name} to ${buildDirName}`);
    const existingLicensePaths = new Set<string>();
    const existingReadmeNames: Array<string> = [];
    // copy all the project files that haven't been copied by tsc
    // this includes all source files, but also other files like README.md, LICENSE, etc.
    const copiedFiles = await copyFiles({
      sourceDir: packageSourceDir,
      targetDir: packageBuildDir,
      overwrite: true,
      keep: ({ entry, directoryPath }) => {
        const isDotFile = entry.name.startsWith(".");
        if (entry.isDirectory()) {
          const isNodeModules = entry.name === "node_modules";
          return (
            !isNodeModules && !isDotFile && directoryPath !== packageBuildDir
          );
        }
        const fullPath = path.join(directoryPath, entry.name);
        // do not keep test files, fixtures, d.ts files, tsconfig.json, nor files generated by this tool
        // TODO: document this behavior
        const isTestFile = entry.name.includes(".test.");
        const isFixtureFile = entry.name.includes(".fixture.");
        const isTypeScriptDeclarationFile = DECLARATION_FILE_EXT_REGEXP.test(
          entry.name,
        );
        const isTypeScriptConfigFile = TSCONFIG_LIKE_FILENAME_REGEXP.test(
          entry.name,
        );
        const isPkgRootDir = packageSourceDir === directoryPath;
        const isPackageJson = isPkgRootDir && entry.name === "package.json";
        const isGeneratedConfigFile =
          configFileAbsolutePaths.includes(fullPath);

        // TODO: respect 'files' field in package.json and .npmignore/.gitignore
        const isPublishableFile =
          !isTestFile &&
          !isFixtureFile &&
          !isTypeScriptDeclarationFile &&
          !isTypeScriptConfigFile &&
          !isPackageJson &&
          !isGeneratedConfigFile &&
          !isDotFile;

        if (isPkgRootDir) {
          if (/^license\..*/i.test(entry.name)) {
            existingLicensePaths.add(fullPath);
          }
          if (/^readme\..*/i.test(entry.name)) {
            existingReadmeNames.push(entry.name);
          }
        }

        return isPublishableFile;
      },
    });

    console.log(`Preparing ${pkg.name} for release`);

    const publishableSourceFiles = copiedFiles.flatMap((f) =>
      f.success ? [f.target] : [],
    );

    const publishManifest = await pkg.generatePublishManifest({
      project,
      publishableSourceFiles,
    });

    // should we just use the whole pack pipeline from pnpm?
    // see https://github.com/pnpm/pnpm/blob/07a7ac4a93505fc75fa397cd4a3965295d76a689/releasing/plugin-commands-publishing/src/pack.ts#L61
    const exportablePackageJson = await createExportableManifest(
      getPublishablePackageDirectory(project, pkg),
      publishManifest as any,
      {
        // support pnpm catalogs
        catalogs,
        // modulesDir is used to resolve 'workspace:' protocol
        // TODO: in non-pnpm we might need to use the root 'node_modules' directory instead, i.e. (workspaceDirAbs, "node_modules")
        modulesDir: path.join(pkg.absPath, "node_modules"),
        readmeFile: existingReadmeNames[0],
      },
    );

    // ensure at least an empty scripts field so NPM publish doesn't complain
    exportablePackageJson.scripts ??= {};

    // save new package.json:
    await fs.writeFile(
      path.join(packageBuildDir, "package.json"),
      JSON.stringify(sortPackageJson(exportablePackageJson), undefined, 2),
    );

    const license = publishManifest.license ?? project.manifest.license;
    if (
      license &&
      license !== "UNLICENSED" &&
      existingLicensePaths.size === 0
    ) {
      // in addition, copy LICENSE if it doesn't exist:
      const licenseDefinition = spdxLicenseList[license];
      if (licenseDefinition) {
        // add LICENSE text file where missing
        const licenseFilePath = path.join(packageBuildDir, "LICENSE");
        await fs.writeFile(
          licenseFilePath,
          licenseDefinition.licenseText
            // TODO: add start year based on git history
            .replace("<year>", new Date().getFullYear().toString())
            .replace(
              "<copyright holders>",
              publishManifest.author?.name ??
                project.manifest.author?.name ??
                "",
            ),
        );
      }
    }
    // TODO: support copying LICENSE(.md/.txt/.rst/etc) from root of project if it exists

    if (existingReadmeNames.length === 0) {
      // if README file doesn't exist, reuse the one from the root of the project:
      const readmeFilePath = path.join(project.absPath, "README.md");
      const packageReadmeFilePath = path.join(packageBuildDir, "README.md");
      try {
        await fs.copyFile(readmeFilePath, packageReadmeFilePath);
      } catch {
        // no README.md in the root of the project
      }
    }

    // publish:
    if (npmTag) {
      const registryParams = publishManifest.publishConfig?.registry
        ? [`--registry`, publishManifest.publishConfig.registry]
        : [];
      // check for existing version on npm
      const existingLatestVersion = await executeNpmCommand({
        npmArgs: [
          "view",
          "--json",
          `${publishManifest.name}@${npmTag}`,
          "version",
          ...registryParams,
        ],
        packageBuildDir,
        parseJson: "always",
        printOutput: false,
      });

      if (
        typeof existingLatestVersion.json === "object" &&
        "error" in existingLatestVersion.json &&
        typeof existingLatestVersion.json.error === "object" &&
        existingLatestVersion.json.error &&
        "code" in existingLatestVersion.json.error
      ) {
        if (existingLatestVersion.json.error.code !== "E404") {
          console.warn(
            `Failed to check for existing version of ${publishManifest.name}:\n${JSON.stringify(
              existingLatestVersion.json.error,
            )}`,
          );
        }
        // package not found, we can publish it
      }

      // TODO: more comprehensive check by semver - if newer version exists, throw an error
      if (existingLatestVersion.json === publishManifest.version) {
        console.log(
          `${publishManifest.name}@${publishManifest.version} previously published to npm, skipping...`,
        );
        // TODO: check if the published version has exactly the same hash and if yes skip, otherwise throw an error
        continue;
      }

      // TODO: make this configurable
      const supportsProvenance =
        publishManifest.publishConfig?.access === "public" &&
        typeof publishManifest.repository === "object" &&
        publishManifest.repository?.url?.includes("https://github.com/");

      // TODO: add support for --provenance https://docs.npmjs.com/generating-provenance-statements
      // needs to detect if "repository" is set in package.json, and propagate it to other package.jsons
      // if it is matching github or gitlab, then we can auto-enable it here
      const { exitCode, stderr, json } = await executeNpmCommand({
        npmArgs: [
          "publish",
          "--json",
          "--tag",
          npmTag,
          ...(supportsProvenance ? ["--provenance"] : []),
          ...(dryRun ? ["--dry-run"] : []),
        ],
        packageBuildDir,
      });
      if (exitCode !== 0) {
        if (typeof json === "object" && "error" in json) {
          throw new Error(
            `Failed to publish ${publishManifest.name}:\n${JSON.stringify(json.error)}`,
          );
        }
        throw new Error(
          `Failed to publish ${publishManifest.name}:\n${stderr}`,
        );
      }
    }
  }
}

const toCompareCase = (str: string) =>
  str.replace(/[^\dA-Za-z]/g, "").toLowerCase();

async function executeNpmCommand({
  npmArgs,
  packageBuildDir,
  parseJson = "on-error",
  printOutput = true,
}: {
  npmArgs: string[];
  packageBuildDir: string;
  parseJson?: "always" | "on-error" | "never";
  printOutput?: boolean;
}) {
  const publishProcess = spawn("npm", npmArgs, { cwd: packageBuildDir });
  let stdout = "";
  publishProcess.stdout.on("data", (data) => {
    stdout += data;
  });
  let stderr = "";
  publishProcess.stderr.on("data", (data) => {
    stderr += data;
  });
  if (printOutput) {
    publishProcess.stdout.pipe(process.stdout);
    publishProcess.stderr.pipe(process.stderr);
  }
  const exitCode = await new Promise<number>((resolve) =>
    publishProcess.on("exit", resolve),
  );
  const json =
    parseJson !== "never" && (parseJson === "always" || exitCode !== 0)
      ? safelyParseLastJsonFromString(stdout) ||
        safelyParseLastJsonFromString(stderr)
      : undefined;
  return { exitCode, stderr, stdout, json };
}

export async function releasePipeline({
  ci = Boolean(process.env["CI"]),
  packages: pkgs,
  ...input
}: {
  packages: string[];
  npmTag?: string;
  ci?: boolean;
  dryRun?: boolean;
}) {
  const applyResult = await apply({ throwOnManualChanges: true });
  if (!applyResult) {
    throw new Error(`Unable to find a condu project in the current directory`);
  }
  const { project, collectedState } = applyResult;
  const { projectConventions } = project;
  const selectedPackagePaths = projectConventions
    ? pkgs.map(
        (packagePath) =>
          getSingleMatch({
            partialPath: packagePath,
            projectConventions,
          }).path,
      )
    : ["."];
  const packages: readonly (WorkspaceRootPackage | WorkspaceSubPackage)[] =
    projectConventions ? project.workspacePackages : [project.workspace];

  const [selectedPackages, unselectedPackages] =
    selectedPackagePaths.length > 0
      ? partition(packages, (pkg) => selectedPackagePaths.includes(pkg.relPath))
      : [packages, []];

  if (selectedPackages.length === 0) {
    throw new Error(`No packages found to prepare for release.`);
  }

  const { absPath: workspaceDirAbs, config } = project;
  // TODO: make conventions non-optional in a loaded project
  const buildDirName = config.conventions.buildDir;
  const srcDirName = config.conventions.sourceDir;
  const absBuildDir = path.join(workspaceDirAbs, buildDirName);

  // await correctSourceMaps({ buildDir: absBuildDir });

  await prepareAndReleaseDirectoryPackages({
    workspaceDirAbs,
    packagesToPrepare: selectedPackages,
    absBuildDir,
    srcDirName,
    buildDirName,
    project,
    collectedState,
    ...input,
  });

  if (ci) {
    // mark all the non-selected packages as private in the package.json
    await Promise.all(
      unselectedPackages
        .filter((pkg) => !pkg.manifest.private)
        .map((pkg) => {
          pkg.addInternalModification((pkg) => ({
            ...pkg,
            $internal$: true,
            private: true,
          }));
          return pkg.applyAndCommit();
        }),
    );
  }
}
