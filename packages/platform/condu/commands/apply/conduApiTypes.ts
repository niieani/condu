import type { Task, DependencyDefinitionInput } from "./CollectedState.js";
import type {
  PackageJsonModifier,
  ReadonlyConduPackageEntry,
  MatchPackage,
} from "./ConduPackageEntry.js";
import type { PeerContext } from "../../extendable.js";
import type {
  DefinedFileNames,
  FallbackFileNames,
  FallbackFileNameToDeserializedTypeMapping,
  GenerateFileOptionsForPath,
  ModifyGeneratedFileOptions,
  ModifyUserEditableFileOptions,
  PartialGlobalFileAttributes,
  ResolvedSerializedType,
} from "./FileManager.js";
import type { ConduProject } from "./ConduProject.js";

export interface ConduApi {
  // TODO: add error / warning collection functions
  readonly project: ReadonlyConduProject;
  readonly root: StateDeclarationApi;
  readonly in: (criteria: MatchPackage) => StateDeclarationApi;
}

export type ReadonlyConduProject = Omit<
  ConduProject,
  "applyAndCommit" | "allPackages" | "workspace" | "workspacePackages"
> & {
  readonly allPackages: readonly ReadonlyConduPackageEntry[];
  readonly workspace: ReadonlyConduPackageEntry<"workspace">;
  readonly workspacePackages: readonly ReadonlyConduPackageEntry<"package">[];
};

export interface StateDeclarationApi {
  ignoreFile(
    path: string,
    options?: Omit<PartialGlobalFileAttributes, "inAllPackages">,
  ): StateDeclarationApi;
  generateFile<PathT extends string>(
    path: PathT,
    options: GenerateFileOptionsForPath<PathT>,
  ): StateDeclarationApi;
  modifyGeneratedFile<PathT extends string>(
    path: PathT,
    options: ModifyGeneratedFileOptions<ResolvedSerializedType<PathT>>,
  ): StateDeclarationApi;
  modifyUserEditableFile<
    PathT extends string,
    DeserializedT = PathT extends FallbackFileNames
      ? FallbackFileNameToDeserializedTypeMapping[PathT]
      : // if no deserializer is defined, we just pass the raw content
        string,
  >(
    path: PathT,
    options: (PathT extends DefinedFileNames
      ? "Error: This file is being generated by Condu. Use modifyGeneratedFile instead."
      : {}) &
      ModifyUserEditableFileOptions<DeserializedT>,
  ): StateDeclarationApi;
  ensureDependency(
    name: string,
    dependency?: DependencyDefinitionInput,
  ): StateDeclarationApi;
  setDependencyResolutions(
    resolutions: Record<string, string>,
  ): StateDeclarationApi;
  modifyPackageJson(modifier: PackageJsonModifier): StateDeclarationApi;
  modifyPublishedPackageJson(
    modifier: PackageJsonModifier,
  ): StateDeclarationApi;
  defineTask(
    name: string,
    taskDefinition: Omit<Task, "name">,
  ): StateDeclarationApi;
}

export type PeerContextReducer = {
  readonly [K in keyof PeerContext]?: (
    current: PeerContext[K],
  ) => PeerContext[K] | Promise<PeerContext[K]>;
};

export type PossibleFeatureNames = keyof PeerContext | (string & {});

export type GetPeerContext<NameT extends PossibleFeatureNames> =
  NameT extends keyof PeerContext ? PeerContext[NameT] : never;

interface FeatureDefinitionSharedProps {
  // todo should this allow regex for dynamically created features?
  after?: Array<string> | string;
}

type FeatureDefinitionPeerContextDependentProps<
  NameT extends PossibleFeatureNames,
> = NameT extends keyof PeerContext
  ? {
      initialPeerContext:
        | GetPeerContext<NameT>
        | ((
            project: ReadonlyConduProject,
          ) => GetPeerContext<NameT> | Promise<GetPeerContext<NameT>>);
      modifyPeerContexts?: (
        project: ReadonlyConduProject,
        initialPeerContext: GetPeerContext<NameT>,
      ) => Promise<PeerContextReducer> | PeerContextReducer;
      defineRecipe?: (
        condu: ConduApi,
        peerContext: GetPeerContext<NameT>,
      ) => void | Promise<void>;
    }
  : {
      defineRecipe?: (condu: ConduApi) => void | Promise<void>;
      modifyPeerContexts?: (
        project: ReadonlyConduProject,
      ) => Promise<PeerContextReducer> | PeerContextReducer;
    };

export type FeatureDefinitionInput<
  NameT extends PossibleFeatureNames = PossibleFeatureNames,
> = FeatureDefinitionSharedProps &
  FeatureDefinitionPeerContextDependentProps<NameT>;

export interface FeatureDefinitionMeta<
  NameT extends PossibleFeatureNames = PossibleFeatureNames,
> {
  name: NameT;
  // TODO: maybe instead of stack just the file path of the feature definition from import.meta.url?
  stack: string;
}

export type FeatureDefinition<
  NameT extends PossibleFeatureNames = PossibleFeatureNames,
> = FeatureDefinitionInput<NameT> & FeatureDefinitionMeta<NameT>;

export type FeatureActionFn = <NameT extends PossibleFeatureNames>(
  name: NameT,
  definition: FeatureDefinitionInput<NameT>,
) => FeatureDefinition<NameT>;
