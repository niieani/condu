import type { PartialProjectConfig, PartialTaskConfig } from "@moonrepo/types";
import type { PackageJson } from "@condu/schema-types/schemas/packageJson.gen.js";
import type { Pattern } from "ts-pattern";
import type { CONFIGURED } from "./configure.js";
import type { ProjectManifest } from "@pnpm/types";
import type {
  ConduPackageEntry,
  ConduProject,
  FeatureDefinition,
  PeerContext,
} from "@condu/cli/commands/apply/applyTypes.js";
import type { Immutable } from "./tsUtils.js";

type AnyObject = {
  readonly [key: string]: any;

  // without this dummy property below, TypeScript will widen to 'any':
  _?: string;
};

export type DependencyTargetList =
  | "dependencies"
  | "devDependencies"
  | "optionalDependencies"
  | "peerDependencies";

export type DependencyDef = {
  readonly name: string;
  readonly installAsAlias?: string;
  /** @default 'devDependencies' */
  readonly list?: DependencyTargetList;
  readonly skipIfExists?: boolean;
  readonly rangePrefix?: "^" | "~" | "";
  /** to what extent should this dependency be managed by condu? */
  readonly managed?: ManagedDependencyConfig | false;
} & (
  | {
      readonly version: string;
      readonly tag?: never;
    }
  | {
      /** @default 'latest' */
      readonly tag?: string | undefined;
      readonly version?: never;
    }
);

export type MinimalManifest = Pick<
  ConduPackageJson,
  DependencyTargetList | "condu"
>;

export interface Task {
  // TODO: allow matching which package the task belongs to, like with Files (matchPackage)
  readonly name: string;
  // format is any transformation in-place
  readonly type: "test" | "build" | "publish" | "format" | "start";
  readonly definition: Immutable<PartialTaskConfig>;
}

export type GetExistingContentFn = <T extends string | object>(
  defaultFallback?: T | undefined,
) => Promise<T | undefined> | T | undefined;

export class SymlinkTarget {
  toString() {
    return `symlink:${this.target}`;
  }
  constructor(public readonly target: string) {}
}

export type FileContent = string | AnyObject | Array<object> | SymlinkTarget;

export interface FileDef {
  /**
   * should this file be ephemeral and is always regenerated by the apply tool (default),
   * or should it be committed?
   * will affect the behavior for features like gitignore
   **/
  type?: "ephemeral" | "committed" | "ignore-only";
  /**
   * always overwrite the file, even if it was changed by the user
   * CAREFUL: this *will* overwrite user changes without warning
   */
  alwaysOverwrite?: boolean;
  /** should this file be published when making a distributable package */
  publish?: boolean;
  /**
   * if you need to access 'state' (e.g. to list all files or tasks),
   * using a function is preferable, as it will be executed *after* all the state had been collected,
   * rather than during its collection, as is the case with pure string or object.
   *
   * if returned an object, the correct stringifier is chosen based on the file extension
   * if a string is returned, it will be written as-is
   **/
  content?:
    | FileContent
    | ((opts: {
        pkg: ConduPackageEntry;
        getExistingContentAndMarkAsUserEditable: GetExistingContentFn;
      }) => Promise<FileContent> | FileContent);
  path: string;
}

export type ManagedDependencyConfig = "presence" | "version";

export interface PackageJsonConduSection
  extends Pick<
    PartialProjectConfig,
    "language" | "platform" | "tags" | "type" | "stack"
  > {
  initialDevelopment?: boolean;
  managedDependencies?: Record<string, ManagedDependencyConfig>;
  defaultScope?: string;
}

export interface ConduPackageJson extends PackageJson {
  // name is mandatory
  name: string;
  condu?: PackageJsonConduSection;

  bolt?: { workspaces?: string[] };
  pnpm?: ProjectManifest["pnpm"];
  resolutions?: Record<string, string>;
  overrides?: Record<string, string>;
}

export interface CollectedTaskDef extends Task {
  featureName: string;
  target: ConduPackageJson;
}

export interface CollectedFileDef extends FileDef {
  featureName: string;
  /**
   * set to true if the file should not be ignored,
   * or list the feature names by which it should be ignored
   *
   * prefer to use type: 'committed' instead, this is used internally
   **/
  skipIgnore?: boolean | string[];
  targetDir: string;
  targetPackage: ConduPackageEntry;
}

export type EntrySources = Record<
  string,
  {
    types?: string;
    source?: string;
    bun?: string;
    import?: string;
    require?: string;
    default?: string;
  }
>;

export interface Hooks {
  modifyPublishPackageJson: (
    packageJson: PackageJson,
  ) => PackageJson | Promise<PackageJson>;
  modifyEntrySourcesForRelease: (
    entrySources: EntrySources,
  ) => EntrySources | Promise<EntrySources>;
}

// export interface CollectedState {
//   /** these files will be created during execution */
//   files: CollectedFileDef[];
//   /** we'll ensure these dependencies are installed during execution */
//   devDependencies: (string | DependencyDef)[];
//   resolutions: Record<string, string>;
//   tasks: CollectedTaskDef[];
//   hooksByPackage: {
//     [packageName: string]: Partial<Hooks>;
//   };
//   autolinkIgnore: string[];
// }

export interface StateFlags {
  // doesn't make sense anymore, we'll always have all tasks defined when writing a file
  preventAdditionalTasks?: boolean;
}

export type Effects = {
  /** these files will be created during execution */
  files?: ReadonlyArray<FileDef | false | undefined>;
  tasks?: ReadonlyArray<Task | false | undefined>;
  hooks?: Partial<Hooks>;

  /** we'll ensure these dependencies are installed during execution */
  devDependencies?: (string | DependencyDef)[];

  /** we'll ensure these dependency resolutions are applied */
  resolutions?: Record<string, string>;

  /**
   * ts-pattern for package.jsons that the state applies to. Defaults to workspace.
   * @default { kind: "workspace" }
   * */
  matchPackage?: MatchPackage;
};

export type MatchPackage =
  | Pattern.Pattern<ConduPackageEntry>
  | Partial<ConduPackageEntry>;

export interface FeatureResult {
  effects?: (Effects | null | undefined | false)[];
  flags?: ReadonlyArray<keyof StateFlags>;
  /**
   * a list of filenames that should not be autolinked,
   * as they are handled directly by the feature
   **/
  autolinkIgnore?: string[];
}

export type FeatureActionFn = (
  config: ConduProject,
  /**
   * TODO: consider lifting 'state' argument to 'content' function of files
   * since the state here is only "collected till now"
   **/
  state: CollectedState,
) => FeatureResult | Promise<FeatureResult | void> | void;

export interface FeatureDefinitionV1 {
  actionFn: FeatureActionFn;
  name: string;
  order?: {
    after?: Array<string>;
    priority?: "beginning" | "end";
  };
}

export interface Conventions {
  /** @default '.' */
  sourceDir?: string;
  sourceExtensions?: string[];
  buildDir?: string;
  /** @default ['.gen', '.generated'] */
  generatedSourceFileNameSuffixes?: string[];

  // TODO: add a convention for test files
}

export interface ResolvedConventionsWithWorkspace
  extends Required<Conventions> {
  projectConventions?: readonly WorkspaceProjectDefined[] | undefined;
}

type GitConfig = {
  /** inferred from git if empty */
  defaultBranch?: string;
};

type NodeConfig = {
  /** @default 'yarn' */
  packageManager?: {
    name: "yarn" | "npm" | "pnpm" | "bun";
    version?: string | undefined;
  };
  version?: string | undefined;
};

type Engine = "node" | "bun";

export interface AutoLinkConfig {
  /** remap file names, key is the filename in .config/, value is the target name */
  mapping?: Record<string, string>;
  ignore?: (string | RegExp)[];
}

export interface ConduConfig {
  /** primary engine used to run the tool */
  engine?: Engine;
  node?: NodeConfig;
  publish?: {
    registry?: string;
    access?: "public" | "restricted";
  };
  git?: GitConfig;
  features: FeatureDefinition<keyof PeerContext>[];
  /** automatically links any config file inside .config/ folder to the root directory and makes it invisible */
  autolink?: boolean | AutoLinkConfig;
  /** when present, assumes monorepo */
  projects?: WorkspaceProjectsConvention[];
  conventions?: Conventions;
}

export interface ConfiguredConduConfig extends ConduConfig {
  [CONFIGURED]: true;
}

export interface ConduConfigWithInferredValues extends ConfiguredConduConfig {
  // TODO: add error / warning functions
  /** absolute path to the workspace */
  workspaceDir: string;
  /** absolute path to the config directory */
  configDir: string;
  conventions: ResolvedConventionsWithWorkspace;
  git: Required<GitConfig>;
  node: Required<NodeConfig>;
  engine: Engine;
}

export type PackageKind = "workspace" | "package";
export type WorkspaceRootPackage = ConduPackageEntry<"workspace">;
export type WorkspaceSubPackage = ConduPackageEntry<"package">;

export interface IPackageEntry<KindT extends PackageKind = PackageKind> {
  kind: KindT;
  /** shortcut to manifest.name */
  name: string;
  scope?: string | undefined;
  scopedName: string;
  manifest: ConduPackageJson;
  manifestRelPath: string;
  manifestAbsPath: string;
  /** relative directory of the package from the workspace path */
  relPath: string;
  /** absolute directory of the package */
  absPath: string;
}

export interface IPackageEntryWithWriteManifest<
  KindT extends PackageKind = PackageKind,
> extends IPackageEntry<KindT> {
  writeProjectManifest: WriteManifestFn;
}

export type GetConduConfigPromise = (
  pkg: ConduPackageEntry,
) => Promise<ConfiguredConduConfig>;

export type ConduConfigInput =
  | ConduConfig
  | ((pkg: ConduPackageEntry) => ConduConfig)
  | ((pkg: ConduPackageEntry) => Promise<ConduConfig>);

export type ConduConfigDefaultExport =
  | ConfiguredConduConfig
  | ((pkg: ConduPackageEntry) => ConfiguredConduConfig)
  | ((pkg: ConduPackageEntry) => Promise<ConfiguredConduConfig>);

export interface LoadConfigOptions {
  startDir?: string;
  throwOnManualChanges?: boolean;
}

export interface WriteManifestFnOptions {
  force?: boolean;
  merge?: boolean;
}

export type WriteManifestFn = (
  manifest: ConduPackageJson | PackageJson,
  options?: WriteManifestFnOptions,
) => Promise<void>;

export interface ProjectConventionConfig {
  private?: boolean;

  /**
   * path to the template folder, relative to the path of the new would-be package
   * it will be used to bootstrap packages created using the convention
   *
   * @default `../@template`
   **/
  templatePath?: string;
}

export interface ParentDirectoryProjectConvention
  extends ProjectConventionConfig {
  /**
   * defines how the name should be created from the project directory name.
   * '*' in the string refers to the project directory name
   * @example when '@condu/*' will name the project '@condu/utils' if the project folder is 'utils'
   * @default '*'
   **/
  nameConvention?: string;
  /**
   * defines the path to the project directory
   * @example when set to 'packages/tools' will expect that packages will live in the 'packages/tools' directory
   **/
  parentPath: string;
}

export interface ExplicitPathProjectConvention extends ProjectConventionConfig {
  path: string;
  name?: string;
}

export type WorkspaceProjectsConvention =
  | ExplicitPathProjectConvention
  | ParentDirectoryProjectConvention
  | string;

export type WorkspaceProjectDefined =
  | ({
      readonly glob: string;
      readonly type: "explicit";
    } & Partial<ExplicitPathProjectConvention>)
  | ({
      readonly glob: string;
      readonly type: "glob";
    } & Partial<ParentDirectoryProjectConvention>);
