import type { stringify } from "node:querystring";
import type {
  ConduConfigWithInferredValuesAndProject,
  ConduPackageJson,
  WorkspacePackage,
} from "./configTypes.js";
import type { WrittenFile } from "@condu/cli/commands/apply/readWrite.js";

// Define PeerContext as an empty interface to be extended via declaration merging
export interface PeerContext {
  // TODO: maybe we move as much of functionality into condu context that's always there?
  condu: { _: string };
}

// Define PeerContextReducer
export type PeerContextReducer = {
  readonly [K in keyof PeerContext]?: (
    current: PeerContext[K],
  ) => PeerContext[K] | Promise<PeerContext[K]>;
};

export type GetPeerContext<NameT extends keyof PeerContext | (string & {})> =
  NameT extends keyof PeerContext ? PeerContext[NameT] : never;

// Define the FeatureDefinition interface for the new API
export type FeatureDefinition<
  NameT extends keyof PeerContext | (string & {}) =
    | keyof PeerContext
    | (string & {}),
> = {
  name: NameT;
  // todo should this allow regex for dynamically created features?
  after?: Array<string> | string;
  mergePeerContext?: (
    config: ConduConfigWithInferredValuesAndProject,
  ) => Promise<PeerContextReducer> | PeerContextReducer;
  apply: (
    condu: Condu,
    peerContext: GetPeerContext<NameT>,
  ) => void | Promise<void>;
} & (NameT extends keyof PeerContext
  ? { initialPeerContext: GetPeerContext<NameT> }
  : {});

export interface Condu {
  config: ConduConfigWithInferredValuesAndProject;
  root: PackageCondu;
  with(criteria: PackageCriteria): PackageCondu;
  packages: WorkspacePackage[];
}

type JsonFileName = `${string}.${"json" | "jsonc" | "json5"}`;
type YamlFileName = `${string}.${"yaml" | "yml"}`;

// a public interface that can be extended by features to include additional file types
// all these need to be created using generateFile call with a parse and stringify method
export interface FileNameToSerializedTypeMapping {
  ".gitignore": Array<string>;
  "package.json": ConduPackageJson;
}

export interface FallbackFileNameToDeserializedTypeMapping {
  [file: JsonFileName]: object;
  [file: YamlFileName]: object;
}

// another public interface that can be extended by features
export interface GlobalFileFlags {
  gitignore?: boolean;
  npmignore?: boolean;
}

type DefinedFileNames = keyof FileNameToSerializedTypeMapping;
type FallbackFileNames = keyof FallbackFileNameToDeserializedTypeMapping;
type PossibleDeserializedValue = object | string | number | boolean | null;

export type ResolvedSerializedType<PathT extends string> =
  PathT extends DefinedFileNames
    ? FileNameToSerializedTypeMapping[PathT]
    : PathT extends FallbackFileNames
      ? FallbackFileNameToDeserializedTypeMapping[PathT]
      : string;

export interface PackageCondu {
  ignoreFile(path: string, options?: GlobalFileFlags): void;
  generateFile<PathT extends string>(
    path: PathT,
    options: GenerateFileOptions<ResolvedSerializedType<PathT>>,
  ): void;
  modifyGeneratedFile<PathT extends string>(
    path: PathT,
    options: ModifyGeneratedFileOptions<ResolvedSerializedType<PathT>>,
  ): void;
  modifyUserEditableFile<
    PathT extends string,
    DeserializedT = PathT extends FallbackFileNames
      ? FallbackFileNameToDeserializedTypeMapping[PathT]
      : // if no deserializer is defined, we just pass the raw content
        string,
  >(
    path: PathT,
    options: (PathT extends DefinedFileNames
      ? "Error: This file is being generated by Condu. Use modifyGeneratedFile instead."
      : {}) &
      ModifyUserEditableFileOptions<DeserializedT>,
  ): void;
  addManagedDevDependency(dependency: string): void;
  addManagedDependency(dependency: string): void;
  setDependencyResolutions(resolutions: Record<string, string>): void;
  mergePackageJson(modifier: (pkg: ConduPackageJson) => ConduPackageJson): void;
  mergeReleasePackageJson(
    modifier: (pkg: ConduPackageJson) => ConduPackageJson,
  ): void;
}

type IfPreviouslyDefined = "error" | "overwrite";

// Define options interfaces
export interface GenerateFileOptions<DeserializedT> extends GlobalFileFlags {
  content:
    | DeserializedT
    | ((pkg: ConduPackageJson) => DeserializedT | Promise<DeserializedT>);

  /** defaults to stringify based on file extension */
  stringify?: (content: DeserializedT) => string;

  /** defaults to 'error' */
  ifPreviouslyDefined?: IfPreviouslyDefined;
}

type IfNotCreated = "ignore" | "error" | "create";

export interface ModifyOnlyGeneratedFileOptions<DeserializedT>
  extends GlobalFileFlags {
  content: (
    content: DeserializedT,
    pkg: ConduPackageJson,
  ) => DeserializedT | Promise<DeserializedT>;
  // default is "ignore"
  ifNotCreated?: Exclude<IfNotCreated, "create">;
}

export interface ModifyOrCreateGeneratedFileOptions<DeserializedT>
  extends GlobalFileFlags {
  content: (
    content: DeserializedT | undefined,
    pkg: ConduPackageJson,
  ) => DeserializedT | Promise<DeserializedT>;

  // for now we can not support 'create' here for simplicity
  ifNotCreated: "create";

  /** defaults to stringify based on file extension */
  stringify?: (content: DeserializedT) => string;
}

export type ModifyGeneratedFileOptions<DeserializedT> =
  | ModifyOnlyGeneratedFileOptions<DeserializedT>
  | ModifyOrCreateGeneratedFileOptions<DeserializedT>;

export type ModifyUserEditableFileOptions<DeserializedT> =
  | ModifyUserEditableFileOptionsWithBuiltinSerialization<DeserializedT>
  | ModifyUserEditableFileOptionsWithCustomSerialization<DeserializedT>;

export interface ModifyUserEditableFileOptionsWithBuiltinSerialization<
  DeserializedT,
> extends GlobalFileFlags {
  // default is true, in which case content signature can include content: undefined
  createIfNotExists?: boolean;
  content: (
    content: DeserializedT | undefined,
    pkg: ConduPackageJson,
  ) => DeserializedT | Promise<DeserializedT>;

  // parse and stringify must exist with a `never` type to make it exact
  // otherwise TS will not discriminate the union correctly
  // by default uses 'json-comment' for .json files, and 'yaml' for .yaml files
  parse?: never;
  stringify?: never;
}

export interface ModifyUserEditableFileOptionsWithCustomSerialization<
  DeserializedT,
> extends GlobalFileFlags {
  createIfNotExists?: boolean;
  content: (
    content: DeserializedT | undefined,
    pkg: ConduPackageJson,
  ) => DeserializedT | Promise<DeserializedT>;

  parse: (rawFileContent: string) => DeserializedT;
  stringify: (content: DeserializedT) => string;
}

export interface PackageCriteria {
  name?: string;
  kind?: "workspace" | "package";
}

// Define types for collected changes
export interface ChangesCollector {
  ignoredFiles: CollectedIgnoreFileChange<string>[];
  generatedFiles: CollectedGenerateFileChange<string>[];
  generatedFilesModifications: CollectedModifyGeneratedFileChange<
    string,
    unknown
  >[];
  userEditableFilesModifications: CollectedModifyUserEditableFileChange<
    string,
    unknown
  >[];
  dependencies: CollectedDependency[];
  resolutions: Record<string, string>;
  packageJsonModifications: PackageJsonModification[];
  releasePackageJsonModifications: PackageJsonModification[];
}

// there needs to be another step to convert those to FileDef

export interface CollectedIgnoreFileChange<PathT extends string> {
  targetPackage: WorkspacePackage;
  path: PathT;
  rootRelativePath: string;
  options: GlobalFileFlags | undefined;
  changeType: "ignore";
}

export interface CollectedGenerateFileChange<PathT extends string> {
  targetPackage: WorkspacePackage;
  path: PathT;
  rootRelativePath: string;
  options: GenerateFileOptions<ResolvedSerializedType<PathT>>;
  changeType: "generate";
}

export interface CollectedModifyGeneratedFileChange<
  PathT extends string,
  DeserializedT,
> {
  targetPackage: WorkspacePackage;
  path: PathT;
  rootRelativePath: string;
  options: ModifyGeneratedFileOptions<DeserializedT>;
  changeType: "modifyGenerated";
}

export interface CollectedModifyUserEditableFileChange<
  PathT extends string,
  DeserializedT,
> {
  targetPackage: WorkspacePackage;
  path: PathT;
  rootRelativePath: string;
  options: ModifyUserEditableFileOptions<DeserializedT>;
  changeType: "modifyUserEditable";
}

export type CollectedFileChange<PathT extends string> =
  | CollectedIgnoreFileChange<PathT>
  | CollectedGenerateFileChange<PathT>
  | CollectedModifyGeneratedFileChange<PathT, unknown>
  | CollectedModifyUserEditableFileChange<PathT, unknown>;

export interface CollectionContext {
  featureName: string;
  // we can consider adding a stack trace here
}

function getDefaultStringify<DeserializedT>(
  path: string,
): (content: DeserializedT) => string {
  // if (path.endsWith(".json")) {
  //   return (content: object) => JSON.stringify(content, null, 2);
  // } else if (path.endsWith(".yaml") || path.endsWith(".yml")) {
  //   return (content: object) => YAML.stringify(content);
  // } else {
  //   throw new Error(
  //     `No default stringify method for file with path ${path}. Please provide a custom stringify method.`,
  //   );
  // }
}

function getDefaultParse<DeserializedT>(
  path: string,
): (rawFileContent: string) => DeserializedT {
  // if (path.endsWith(".json")) {
  //   return (rawFileContent: string) => JSON.parse(rawFileContent);
  // } else if (path.endsWith(".yaml") || path.endsWith(".yml")) {
  //   return (rawFileContent: string) => YAML.parse(rawFileContent);
  // } else {
  //   throw new Error(
  //     `No default parse method for file with path ${path}. Please provide a custom parse method.`,
  //   );
  // }
}

type ModifyUserEditableFileOptionsWithContext<
  DeserializedT extends PossibleDeserializedValue,
> = ModifyUserEditableFileOptions<DeserializedT> & {
  context: CollectionContext;
};

type ModifyGeneratedFileOptionsWithContext<
  DeserializedT extends PossibleDeserializedValue,
> = ModifyGeneratedFileOptions<DeserializedT> & {
  context: CollectionContext;
};

type FileKind =
  | "flags-only"
  | "generated"
  | "user-editable"
  | "symlink"
  | "invalid";

class FileProcessingPipeline<DeserializedT extends PossibleDeserializedValue> {
  path: string;
  // kind: "flags-only" | "generated" | "user-editable" | "symlink" = "flags-only";
  flags: GlobalFileFlags = {};
  targetPackage: WorkspacePackage;
  pipelineContextBreadcrumbs: CollectionContext[] = [];
  status: "pending" | "applied" | "ignored" = "pending";

  symlinkTarget?: string;
  initialContent?:
    | DeserializedT
    | ((pkg: ConduPackageJson) => DeserializedT | Promise<DeserializedT>);
  contentModifications: Array<
    ModifyGeneratedFileOptionsWithContext<DeserializedT>
  > = [];
  editableContentModifications: Array<
    ModifyUserEditableFileOptionsWithContext<DeserializedT>
  > = [];

  // defaults to stringify based on file extension
  stringify: (content: DeserializedT) => string;

  // TODO: path should be relative from repo root
  // move targetPackage out to addInitialContent/modification
  constructor(
    path: string,
    targetPackage: WorkspacePackage,
    flags: GlobalFileFlags,
  ) {
    this.path = path;
    this.flags = flags;
    // TODO: handle edge case - prevent reaching into other packages by using relative paths or from root (e.g. by specifiying root package + ./packages/file as the path)
    this.targetPackage = targetPackage;
    // set default stringify based on file name/extension
    this.stringify = getDefaultStringify(this.path);
  }

  updateFlags(flags: GlobalFileFlags) {
    // only set the flags that are provided
    for (const [key, value] of Object.entries(flags)) {
      // flags can only be string, number or boolean
      if (
        typeof value === "string" ||
        typeof value === "number" ||
        typeof value === "boolean"
      ) {
        this.flags[key as keyof GlobalFileFlags] = value as NonNullable<
          GlobalFileFlags[keyof GlobalFileFlags]
        >;
      }
    }
  }

  addInitialContent({
    content,
    stringify,
    context,
    ifPreviouslyDefined = "error",
    ...flags
  }: GenerateFileOptions<DeserializedT> & { context: CollectionContext }) {
    this.pipelineContextBreadcrumbs.push(context);
    this.updateFlags(flags);
    if (this.initialContent && ifPreviouslyDefined === "error") {
      // TODO: safe error handling instead of throwing
      throw new Error(`Initial content already set for file ${this.path}`);
    }
    this.initialContent = content;
    if (stringify) {
      this.stringify = stringify;
    }
  }

  addModification(
    modification: ModifyGeneratedFileOptionsWithContext<DeserializedT>,
  ) {
    const {
      content,
      context,
      // TODO: maybe a cleaner way to extract flags?
      ...flags
    } = modification;
    this.pipelineContextBreadcrumbs.push(context);
    this.updateFlags(flags);
    this.contentModifications.push(modification);
  }

  addUserEditableModification(
    modification: ModifyUserEditableFileOptionsWithContext<DeserializedT>,
  ) {
    // it's okay to allow modifications to generated files
    // because we can stringify and parse them
    // but it has to happen after all generated modifications

    // what about the opposite?
    // if (this.kind === 'generated') {
    //   throw new Error(`Cannot modify a generated file, use modifyGeneratedFile instead`);
    // }
    const {
      content,
      context,
      parse,
      stringify,
      createIfNotExists,
      // TODO: maybe a cleaner way to extract flags?
      ...flags
    } = modification;
    this.pipelineContextBreadcrumbs.push(context);
    this.updateFlags(flags);
    this.editableContentModifications.push(modification);

    // TODO: we should re-parse and re-stringify after each modification?
    // if (!this.parse) {
    //   this.parse = parse ?? getDefaultParse(this.path)
    // }
    // if (stringify) {
    //   this.stringify = stringify;
    // }
  }

  setSymlinkTarget(target: string) {
    this.symlinkTarget = target;
  }

  async applyAndCommit(): Promise<FileKind> {
    // depending on the kind:
    // reads the file content
    // parses the file content
    // applies the modifications
    // writes the file content

    if (this.symlinkTarget) {
      await this.updateSymlink();
      return "symlink";
    }

    let kind: FileKind = "flags-only";

    // move all modifications with createIfNotExists: false to the end
    this.editableContentModifications.sort((a, b) =>
      a.createIfNotExists === false
        ? 1
        : b.createIfNotExists === false
          ? -1
          : 0,
    );

    // move all modifications with ifNotCreated: "create" to the beginning
    this.contentModifications.sort((a, b) =>
      a.ifNotCreated === "create" ? -1 : b.ifNotCreated === "create" ? 1 : 0,
    );

    let content: DeserializedT | undefined =
      typeof this.initialContent === "function"
        ? await this.initialContent(this.targetPackage)
        : this.initialContent;

    let ifNotCreated: IfNotCreated = "ignore";

    // reduce the content to the final state
    for (const modification of this.contentModifications) {
      if (content === undefined && modification.ifNotCreated === "create") {
        // if no content, try the modification that can create the file
        content = await modification.content(undefined, this.targetPackage);
        if (modification.stringify) {
          this.stringify = modification.stringify;
        }
      } else {
        if (modification.ifNotCreated === "error") {
          ifNotCreated = "error";
        }
        if (content === undefined) {
          if (ifNotCreated === "error") {
            throw new Error(
              `Cannot generate ${this.path}, no initial content provided`,
            );
          }
          this.status = "ignored";
          // nothing to do, finish here
          return "invalid";
        }
        content = await modification.content(content, this.targetPackage);
      }
      // TODO: add debugging breadcrumbs for actually applied creations / modifications
    }

    if (content !== undefined) {
      // if by this point we got content, it's a generated file
      kind = "generated";
    }

    let stringified: string | undefined =
      content !== undefined ? this.stringify(content) : undefined;

    if (this.editableContentModifications.length > 0) {
      if (stringified) {
        // TODO: warn that we are editing a generated file, not a user-provided one
      }
      // user-editable files get parsed from the filesystem contents
      stringified = stringified ?? (await this.getContentFromFileSystem());
    }

    for (const modification of this.editableContentModifications) {
      const parse = modification.parse ?? getDefaultParse(this.path);
      content = stringified ? parse(stringified) : undefined;
      if (content === undefined) {
        if (modification.createIfNotExists === false) {
          throw new Error(
            `Cannot modify ${this.path}, no initial content provided`,
          );
        } else {
          this.status = "ignored";
          // nothing to do, finish here
          return "invalid";
        }
      }

      if (kind !== "generated") {
        kind = "user-editable";
      }

      // get the next version of the content:
      content = await modification.content(content, this.targetPackage);
      const stringify =
        modification.stringify ?? getDefaultStringify(this.path);
      stringified = stringify(content);
    }

    if (stringified) {
      await this.writeToFileSystem(stringified, kind === "user-editable");
    }

    this.status = "applied";

    return kind;
  }

  /**
   * the current file as is present in the FS
   * if the file was deleted, this will be "deleted"
   * if the fsState is the same as lastApply, this will be "unchanged"
   **/
  _fsState?: Omit<WrittenFile, "path"> | "deleted" | "unchanged";
  lastApply?: WrittenFile;

  async ensureFsState(): Promise<
    Omit<WrittenFile, "path"> | "deleted" | "unchanged"
  > {
    if (this._fsState) {
      return this._fsState;
    }
    // TODO
    // read the file
    // store in this.fsState
    // if file doesn't exist, store "deleted" (maybe rename to 'nonexistent'?)
  }

  async getFsFile(): Promise<Omit<WrittenFile, "path"> | "nonexistent"> {
    const fsState = await this.ensureFsState();
    if (typeof fsState === "object") {
      return fsState;
    }
    if (fsState === "unchanged" && this.lastApply) {
      return this.lastApply;
    }
    if (fsState === "deleted") {
      return "nonexistent";
    }
  }

  async getContentFromFileSystem(): Promise<string | undefined> {
    const file = await this.getFsFile();
    if (typeof file === "object" && typeof file.content === "string") {
      return file.content;
    }
    return undefined;
  }

  async writeToFileSystem(
    content: string,
    overwriteWithoutAsking = false,
  ): Promise<void> {
    // TODO
    // compare with the fs content
    // if different:
    // option to resolve conflicts
    // write to fs
    // update this._fsState
    // update this.lastApply
    // somewhere else: update cache
  }

  async updateSymlink(): Promise<void> {
    const fsState = await this.ensureFsState();
    if (typeof fsState === "object") {
      if (typeof fsState.content === "object") {
        if (fsState.content.target === this.symlinkTarget) {
          // nothing to do
          return;
        } else {
          // TODO: remove the symlink, will create a new one below
        }
      } else {
        // TODO: warn that the file would be overwritten by a symlink
        // err on the side of caution
        return;
      }
    }
    // TODO: write the symlink and update this._fsState
  }
}

export interface CollectedDependency {
  pkg: WorkspacePackage;
  dependency: string;
  type: "dev" | "prod";
}

export interface PackageJsonModification {
  pkg: WorkspacePackage;
  modifier: (pkg: ConduPackageJson) => ConduPackageJson;
}
