# ./packages/features/editorconfig/editorconfig.ts

## before

```ts
import { defineFeature } from "condu/defineFeature.js";
import { serializeEditorConfig } from "./serialize.js";
import type { EditorConfig } from "./types.js";

const defaultConfig: EditorConfig = {
  root: true,
  sections: {
    "*": {
      indent_style: "space",
      indent_size: 2,
      end_of_line: "lf",
      charset: "utf-8",
      trim_trailing_whitespace: true,
      insert_final_newline: true,
      max_line_length: 80,
    },
  },
};

export const editorconfig = (config: EditorConfig = defaultConfig) =>
  defineFeature({
    name: "editorconfig",
    actionFn: (_config, state) => ({
      effects: [
        {
          files: [
            {
              path: ".editorconfig",
              content: serializeEditorConfig(config),
            },
          ],
        },
      ],
    }),
  });
```

## after

```ts
import { defineFeature } from "condu/defineFeature.js";
import { serializeEditorConfig } from "./serialize.js";
import type { EditorConfig, EditorConfigSection } from "./types.js";

const defaultConfig: EditorConfig = {
  root: true,
  sections: {
    "*": {
      indent_style: "space",
      indent_size: 2,
      end_of_line: "lf",
      charset: "utf-8",
      trim_trailing_whitespace: true,
      insert_final_newline: true,
      max_line_length: 80,
    },
  },
};

declare module "@condu/types/extendable.js" {
  interface PeerContext {
    editorconfig: {
      sections: Record<string, EditorConfigSection>;
    };
  }
  interface FileNameToSerializedTypeMapping {
    ".editorconfig": EditorConfig;
  }
}

export const editorconfig = (config?: EditorConfig) =>
  defineFeature("editorconfig", {
    initialPeerContext: {
      sections: config?.sections ?? defaultConfig.sections,
    },
    defineRecipe(condu, { sections }) {
      condu.root.generateFile(".editorconfig", {
        content: {
          ...defaultConfig,
          sections,
        },
        stringify: serializeEditorConfig,
      });
    },
  });
```

# ./packages/features/eslint/eslint.ts

## before

```ts
import { defineFeature } from "condu/defineFeature.js";
import { pick } from "remeda";
import type {
  ContextProvidedToEslintConfig,
  EslintFeatureInput,
} from "./types.js";
import path from "node:path";

const RUNNING_SOURCE_VERSION = import.meta.url.endsWith(".ts");

export const eslint = ({
  importAdditionalConfigFrom,
  defaultRules = {},
  ignores = [],
}: { importAdditionalConfigFrom?: string } & EslintFeatureInput = {}) =>
  defineFeature({
    name: "eslint",
    actionFn: (config, state) => {
      const needsTypeScript =
        RUNNING_SOURCE_VERSION || importAdditionalConfigFrom?.endsWith(".ts");
      return {
        autolinkIgnore: importAdditionalConfigFrom
          ? [importAdditionalConfigFrom]
          : [],
        effects: [
          {
            files: [
              {
                path: "eslint.config.js",
                content: () => {
                  const eslintContext: ContextProvidedToEslintConfig = {
                    ...pick(config, ["conventions", "projects"]),
                    ignores: [
                      ...state.files.map(({ path: p, targetDir }) =>
                        targetDir === "."
                          ? `${p}`
                          : `${targetDir}/${path.normalize(p)}`,
                      ),
                      ...ignores,
                    ],
                    defaultRules,
                  };
                  return `// note: this file was auto-generated by condu
// if you want to make changes, edit the .config/condu.ts file instead

import { getConfigs } from "@condu-feature/eslint/config.${
                    needsTypeScript ? "ts" : "js"
                  }";
${importAdditionalConfigFrom ? `import additionalConfigs from "./.config/${path.normalize(importAdditionalConfigFrom)}";` : ""}
const configs = getConfigs(${JSON.stringify(eslintContext, undefined, 2)}${importAdditionalConfigFrom ? ", additionalConfigs" : ""});
export default configs;\n`;
                },
              },
            ],
            devDependencies: [
              "eslint",
              "eslint-plugin-import-x",
              "eslint-plugin-unicorn",
              "eslint-import-resolver-typescript",
              "@eslint/js",
              "@typescript-eslint/parser",
              "@typescript-eslint/eslint-plugin",
              ...(needsTypeScript ? ["tsx"] : []),
            ],
            tasks: [
              {
                name: "eslint",
                type: "test",
                definition: {
                  command: "eslint",
                  inputs: ["@group(sources)"],
                  ...(needsTypeScript
                    ? {
                        // TODO: consider node strip types instead
                        env: { NODE_OPTIONS: "--import tsx/esm" },
                      }
                    : {}),
                },
              },
            ],
          },
        ],
      };
    },
  });
```

## after

```ts
import { defineFeature } from "condu/defineFeature.js";
import { pick } from "remeda";
import type {
  ContextProvidedToEslintConfig,
  EslintFeatureInput,
} from "./types.js";
import path from "node:path";
import { CONDU_CONFIG_DIR_NAME } from "@condu/types/constants.js";

const RUNNING_SOURCE_VERSION = import.meta.url.endsWith(".ts");

export interface EslintFeatureConfig extends EslintFeatureInput {
  importAdditionalConfigFrom?: string;
}

export interface EslintFeaturePeerContext extends Required<EslintFeatureInput> {
  importAdditionalConfigFrom?: string;
}

declare module "@condu/types/extendable.js" {
  interface PeerContext {
    eslint: EslintFeaturePeerContext;
  }
}

export const eslint = (config: EslintFeatureConfig = {}) =>
  defineFeature("eslint", {
    initialPeerContext: {
      ...config,
      defaultRules: config.defaultRules ?? {},
      ignores: config.ignores ?? [],
    },

    modifyPeerContexts: (project, initialPeerContext) => ({
      global: (current) => ({
        ...current,
        execWithTsSupport:
          RUNNING_SOURCE_VERSION ||
          initialPeerContext.importAdditionalConfigFrom?.endsWith(".ts") ||
          current.execWithTsSupport,
      }),
      vscode: (current) => ({
        ...current,
        suggestedSettings: {
          ...current.suggestedSettings,
          "eslint.lintTask.enable": true,
          "eslint.useESLintClass": true,
          "eslint.runtime": "node",
        },
        enforcedSettings: {
          ...current.enforcedSettings,
          ...(project.config.globalPeerContext.execWithTsSupport
            ? {
                "eslint.execArgv": [
                  "--import",
                  import.meta.resolve("tsx/esm").slice("file://".length),
                ],
              }
            : {}),
        },
      }),
    }),

    defineRecipe(condu, { defaultRules, ignores, importAdditionalConfigFrom }) {
      const execWithTsSupport =
        condu.project.config.globalPeerContext.execWithTsSupport;

      condu.root.generateFile("eslint.config.js", {
        content({ globalRegistry }) {
          const eslintContext: ContextProvidedToEslintConfig = {
            ...pick(condu.project.config, ["conventions", "projects"]),
            ignores: [
              ...globalRegistry.files.map(([filePath]) => filePath),
              ...ignores,
            ],
            defaultRules,
          };
          return /* ts */ `
// note: this file was auto-generated by condu
// if you want to make changes, edit the .config/condu.ts file instead

import { getConfigs } from "@condu-feature/eslint/config.${execWithTsSupport ? "ts" : "js"}";
${importAdditionalConfigFrom ? `import additionalConfigs from "./${CONDU_CONFIG_DIR_NAME}/${path.normalize(importAdditionalConfigFrom)}";` : ""}
const configs = getConfigs(${JSON.stringify(eslintContext, undefined, 2)}${importAdditionalConfigFrom ? ", additionalConfigs" : ""});
export default configs;
`.trimStart();
        },
      });

      condu.root.ensureDependency("eslint");
      condu.root.ensureDependency("eslint-plugin-import-x");
      condu.root.ensureDependency("eslint-plugin-unicorn");
      condu.root.ensureDependency("eslint-import-resolver-typescript");
      condu.root.ensureDependency("@eslint/js");
      condu.root.ensureDependency("@typescript-eslint/parser");
      condu.root.ensureDependency("@typescript-eslint/eslint-plugin");
      if (execWithTsSupport) {
        condu.root.ensureDependency("tsx");
      }

      condu.root.defineTask("eslint", {
        type: "test",
        definition: {
          command: "eslint",
          inputs: ["@group(sources)"],
          ...(execWithTsSupport
            ? // TODO: consider node strip types instead
              { env: { NODE_OPTIONS: "--import tsx/esm" } }
            : {}),
        },
      });
    },
  });
```

# ./packages/features/gitignore/gitignore.ts

## before

```ts
import { CONDU_CONFIG_DIR_NAME } from "@condu/types/constants.js";
import { defineFeature } from "condu/defineFeature.js";
import * as path from "node:path";
import { groupBy } from "remeda";

export const gitignore = ({ ignore = [] }: { ignore?: string[] } = {}) =>
  defineFeature({
    name: "gitignore",
    order: { priority: "end" },
    actionFn: (config, state) => ({
      effects: [
        {
          files: [
            {
              path: ".gitignore",
              content: () => {
                const filesByFeature = groupBy(
                  state.files.filter(
                    ({ type, skipIgnore }) =>
                      type !== "committed" && !skipIgnore,
                  ),
                  ({ featureName }) => featureName,
                );
                const entriesFromFeatures = Object.entries(
                  filesByFeature,
                ).flatMap(([featureName, files]) => {
                  if (featureName === "gitignore") return [];
                  return [
                    `# ${featureName}:`,
                    ...files.map(({ path: p, targetDir, type }) =>
                      type === "ignore-only"
                        ? p
                        : `/${path.join(targetDir, p)}`,
                    ),
                  ];
                });
                return (
                  [
                    ".DS_Store",
                    "node_modules",
                    `/${CONDU_CONFIG_DIR_NAME}/.cache/`,
                    `/${config.conventions.buildDir}/`,
                    // ignore all generated files:
                    ...entriesFromFeatures,
                    ...(ignore.length > 0 ? ["# custom ignore patterns:"] : []),
                    ...ignore,
                  ].join("\n") + "\n"
                );
              },
            },
          ],
        },
      ],
    }),
  });
```

## after

```ts
import { CONDU_CONFIG_DIR_NAME } from "@condu/types/constants.js";
import { defineFeature } from "condu/defineFeature.js";
import { groupBy } from "remeda";

export interface IgnoreConfig {
  ignore?: string[];
}

declare module "@condu/types/extendable.js" {
  interface PeerContext {
    gitignore: Required<IgnoreConfig>;
  }
  interface FileNameToSerializedTypeMapping {
    ".gitignore": Array<string>;
  }
  interface GlobalFileAttributes {
    gitignore: boolean;
  }
}

export const gitignore = (opts: IgnoreConfig = {}) =>
  defineFeature("gitignore", {
    initialPeerContext: { ignore: opts.ignore ?? [] },

    defineRecipe(condu, { ignore }) {
      condu.root.generateFile(".gitignore", {
        content({ globalRegistry }) {
          const files = globalRegistry.getFilesMatchingAttribute("gitignore", {
            includeUnflagged: true,
          });
          const filesByFeature = groupBy(
            [...files],
            ([_path, file]) =>
              file.managedByFeatures[0]?.featureName ?? "unmanaged",
          );
          const entriesFromFeatures = Object.entries(filesByFeature).flatMap(
            ([featureName, files]) => {
              if (featureName === "gitignore") return [];
              return [`# ${featureName}:`, ...files.map(([p]) => `/${p}`)];
            },
          );
          // TODO: option to group all inAllPackages files by adding a single non / prefixed entry for a cleaner output
          return [
            ".DS_Store",
            "node_modules",
            `/${CONDU_CONFIG_DIR_NAME}/.cache/`,
            `/${condu.project.config.conventions.buildDir}/`,
            // ignore all generated files:
            ...entriesFromFeatures,
            ...(ignore.length > 0 ? ["# custom ignore patterns:"] : []),
            ...ignore,
          ];
        },

        stringify(content) {
          return content.join("\n") + "\n";
        },
      });
    },
  });
```

# ./packages/features/vscode/vscode.ts

## before

```ts
import { defineFeature } from "condu/defineFeature.js";
import { assign } from "comment-json";
import type { VscodeSettingsWorkspace } from "@condu/schema-types/schemas/vscodeSettingsWorkspace.gen.js";
import * as path from "node:path";

const RUNNING_SOURCE_VERSION = import.meta.url.endsWith(".ts");

const defaultEnforcedConfig: VscodeSettingsWorkspace = {
  ...(RUNNING_SOURCE_VERSION
    ? {
        "eslint.execArgv": [
          "--import",
          import.meta.resolve("tsx/esm").slice("file://".length),
        ],
      }
    : {}),
};

const defaultSuggestedConfig: VscodeSettingsWorkspace = {
  // TODO: only add these eslint settings if the eslint feature is enabled
  "eslint.lintTask.enable": true,
  "eslint.useESLintClass": true,
  // forces vscode to run eslint with the node version installed in the system,
  // instead of the one bundled with vscode
  "eslint.runtime": "node",
  // "eslint.runtime": process.argv0,
  "typescript.tsserver.experimental.enableProjectDiagnostics": true,
  "typescript.tsdk": "node_modules/typescript/lib",
};

export const vscode = ({
  suggestedConfig = {},
  enforcedConfig = {},
  hideGeneratedFiles = false,
}: {
  hideGeneratedFiles?: boolean;
  suggestedConfig?: VscodeSettingsWorkspace;
  enforcedConfig?: VscodeSettingsWorkspace;
} = {}) =>
  defineFeature({
    name: "vscode",
    order: { priority: "end" },
    actionFn: async (config, state) => {
      // TODO: also, auto-add 'tasks.json' based on the defined tasks
      return {
        effects: [
          {
            files: [
              {
                path: ".vscode/settings.json",
                content: async ({
                  getExistingContentAndMarkAsUserEditable: getExistingContent,
                }) => {
                  const existingContent =
                    ((await getExistingContent()) as VscodeSettingsWorkspace) ??
                    {};
                  const excludedFiles = hideGeneratedFiles
                    ? Object.fromEntries(
                        state.files
                          .filter(
                            ({ type, skipIgnore, featureName }) =>
                              type !== "committed" &&
                              !skipIgnore &&
                              featureName !== "vscode",
                          )
                          .map(({ path: p, targetDir }) => [
                            // remove leading './' from path
                            path.normalize(path.join(targetDir, p)),
                            true,
                          ]),
                      )
                    : {};
                  const withEnforcedConfig = assign(existingContent, {
                    ...defaultEnforcedConfig,
                    ...enforcedConfig,
                    "files.exclude": {
                      ...excludedFiles,
                      ...enforcedConfig?.["files.exclude"],
                    },
                    "search.exclude": {
                      [config.conventions.buildDir]: true,
                    },
                  } satisfies VscodeSettingsWorkspace);
                  const suggestedConfigWithDefaults = {
                    ...defaultSuggestedConfig,
                    ...suggestedConfig,
                  };
                  return assign(
                    suggestedConfigWithDefaults,
                    withEnforcedConfig,
                  );
                },
              },
            ],
            devDependencies: RUNNING_SOURCE_VERSION ? ["tsx"] : [],
          },
        ],
      };
    },
  });
```

## after

```ts
import { defineFeature } from "condu/defineFeature.js";
import { assign } from "comment-json";
import type { VscodeSettingsWorkspace } from "@condu/schema-types/schemas/vscodeSettingsWorkspace.gen.js";
import { getYamlParseAndStringify } from "@condu/cli/commands/apply/defaultParseAndStringify.js";

const RUNNING_SOURCE_VERSION = import.meta.url.endsWith(".ts");

// TODO: move these to TypeScript feature:
const defaultSuggestedSettings: VscodeSettingsWorkspace = {
  "typescript.tsserver.experimental.enableProjectDiagnostics": true,
  "typescript.tsdk": "node_modules/typescript/lib",
};

declare module "@condu/types/extendable.js" {
  interface PeerContext {
    vscode: VSCodePeerContext;
  }
  interface GlobalFileAttributes {
    vscode: boolean;
  }
}

interface VSCodePeerContext {
  suggestedSettings: VscodeSettingsWorkspace;
  enforcedSettings: VscodeSettingsWorkspace;
}

interface VSCodeConfig extends Partial<VSCodePeerContext> {
  hideGeneratedFiles?: boolean;
}

export const vscode = ({
  hideGeneratedFiles = false,
  ...config
}: VSCodeConfig = {}) =>
  defineFeature("vscode", {
    initialPeerContext: {
      suggestedSettings: config.suggestedSettings ?? {},
      enforcedSettings: config.enforcedSettings ?? {},
    },

    modifyPeerContexts: () => ({
      global: (current) => ({
        ...current,
        execWithTsSupport: current.execWithTsSupport || RUNNING_SOURCE_VERSION,
      }),
    }),

    defineRecipe(condu, { suggestedSettings, enforcedSettings }) {
      condu.root.modifyUserEditableFile(".vscode/settings.json", {
        content({ content = {}, globalRegistry }) {
          const excludedFiles = [
            // TODO: potentially add a global 'alwaysVisibleInEditor' flag to indicate a file might not be hidden
            ...globalRegistry.getFilesMatchingAttribute("gitignore", {
              includeUnflagged: true,
            }),
          ].filter(
            ([_relPath, file]) =>
              !file.managedByFeatures.some(
                (context) => context.featureName === "vscode",
              ),
          );
          const withEnforcedConfig = assign(content, {
            ...enforcedSettings,
            "files.exclude": {
              ...(hideGeneratedFiles
                ? Object.fromEntries(
                    excludedFiles.map(([relPath]) => [relPath, true]),
                  )
                : {}),
              ...enforcedSettings?.["files.exclude"],
            },
            "search.exclude": {
              [condu.project.config.conventions.buildDir]: true,
              ...enforcedSettings?.["search.exclude"],
            },
          } satisfies VscodeSettingsWorkspace);
          const suggestedConfigWithDefaults = {
            ...defaultSuggestedSettings,
            ...suggestedSettings,
          };
          return assign(suggestedConfigWithDefaults, withEnforcedConfig);
        },
        ...getYamlParseAndStringify<VscodeSettingsWorkspace>(),
      });

      // TODO: also, auto-add 'tasks.json' based on the defined tasks
    },
  });
```

# ./packages/features/ci-github-actions/moon.ts

## before

```ts
import { defineFeature } from "condu/defineFeature.js";
import type { GithubWorkflow } from "@condu/schema-types/schemas/githubWorkflow.gen.js";
import type {
  PartialTaskConfig,
  PartialProjectConfig as Project,
} from "@moonrepo/types";
import { otherSchemas as schemas } from "@condu/schema-types/utils/schemas.js";
import { mapValues } from "remeda";
import type { Effects, Task, Conventions } from "@condu/types/configTypes.js";
import type { GithubAction } from "@condu/schema-types/schemas/githubAction.gen.js";

type TasksByType = Record<
  Task["type"],
  [projectName: string, taskName: string][]
>;

export const moonCi = (opts: {} = {}) =>
  defineFeature({
    name: "moonCi",
    order: { priority: "end" },
    actionFn: async (config, state) => {
      const packageManager = config.node.packageManager.name;
      const ciSetupAction: GithubAction = {
        name: "Moon CI Setup",
        description: "Setup the environment for Moon CI",
        inputs: {
          "registry-url": {
            description: "The NPM registry URL",
            required: false,
            default: "https://registry.npmjs.org/",
          },
        },
        runs: {
          using: "composite",
          steps: [
            ...(config.node.packageManager.name !== "npm"
              ? [{ run: `corepack enable`, shell: "bash" }]
              : []),
            {
              uses: "actions/setup-node@v4",
              with: {
                "node-version-file": "package.json",
                // "node-version": config.node.version,
                cache: config.node.packageManager.name,
                "registry-url": "${{ inputs.registry-url }}",
              },
            },
            { uses: "oven-sh/setup-bun@v1" },
            {
              run: `${packageManager} ${
                packageManager === "yarn"
                  ? "install --immutable"
                  : packageManager === "npm"
                    ? "ci"
                    : "install --frozen-lockfile"
              }`,
              shell: "bash",
            },
            {
              run: `./node_modules/.bin/moon ci :build`,
              shell: "bash",
              env: { MOON_TOOLCHAIN_FORCE_GLOBALS: "true" },
            },
          ],
        },
      };
      const ciWorkflow: GithubWorkflow = {
        name: "Moon CI",
        on: {
          push: { branches: [config.git.defaultBranch] },
          pull_request: {},
        },
        env: {
          GIT_DEFAULT_BRANCH: "${{ github.event.repository.default_branch }}",
        },
        jobs: {
          ci: {
            name: "Moon CI",
            "runs-on": "ubuntu-latest",
            env: { MOON_TOOLCHAIN_FORCE_GLOBALS: "true" },
            steps: [
              {
                uses: "actions/checkout@v4",
                with: { "fetch-depth": 0 },
              },
              {
                name: "Moon CI Setup",
                uses: "./.github/actions/moon-ci-setup",
              },
              {
                name: "Test",
                run: `./node_modules/.bin/moon ci :test`,
                shell: "bash",
              },
            ],
          },
        },
      };

      const packages = [
        ...(await config.project.getWorkspacePackages()),
        config.project,
      ];
      const taskList = state.tasks;
      const tasksByType: TasksByType = {
        build: [],
        test: [],
        format: [],
        publish: [],
        start: [],
      };

      const projectStates = packages.flatMap<Effects>((pkg) => {
        const tasksForProject = taskList.flatMap((task) => {
          if (task.name in tasksByType) {
            throw new Error(
              `In ${pkg.manifest.name}: Task name '${task.name}' is reserved for the global task type`,
            );
          }
          if (task.target.name === pkg.manifest.name) {
            tasksByType[task.type].push([pkg.manifest.name, task.name]);
            return [[task.name, task.definition]] as const;
          }
          return [];
        });
        if (tasksForProject.length === 0 && pkg.kind === "package") {
          return [];
        }
        return {
          matchPackage: {
            name: pkg.manifest.name,
            kind: pkg.kind,
          },
          files: [
            {
              path: "moon.yml",
              content: {
                $schema: schemas.project,
                tasks:
                  pkg.kind === "package"
                    ? Object.fromEntries(tasksForProject)
                    : {
                        ...Object.fromEntries(tasksForProject),
                        ...getWorkspaceTasks({
                          tasksByType,
                          conventions: config.conventions,
                        }),
                      },
              } satisfies Project,
            },
          ],
        } as const;
      });

      return {
        effects: [
          ...projectStates,
          {
            files: [
              {
                path: ".github/actions/moon-ci-setup/action.yml",
                type: "committed",
                content: ciSetupAction,
              },
              {
                path: ".github/workflows/moon-ci.yml",
                type: "committed",
                content: ciWorkflow,
              },
            ],
          },
        ],

        flags: ["preventAdditionalTasks"],
      };
    },
  });

function getWorkspaceTasks({
  tasksByType,
  conventions,
}: {
  tasksByType: TasksByType;
  conventions: Required<Conventions>;
}): Record<string, PartialTaskConfig> {
  const tasks = mapValues(
    tasksByType,
    (tasks, type): PartialTaskConfig => ({
      deps: tasks.map(
        ([projectName, taskName]) => `${projectName}:${taskName}`,
      ),
      inputs: [],
      ...(type === "publish" && { options: { runDepsInParallel: false } }),
      ...(type === "format" && { options: { runInCI: false } }),
    }),
  );

  return {
    ...tasks,
    clean: {
      command: `rm -rf ${conventions.buildDir} .moon/cache/states`,
      options: { cache: false, runInCI: false },
    },
  };
}
```

## after

```ts
import { defineFeature } from "condu/defineFeature.js";
import type { GithubWorkflow } from "@condu/schema-types/schemas/githubWorkflow.gen.js";
import type {
  PartialTaskConfig as MoonTask,
  PartialProjectConfig as MoonProject,
} from "@moonrepo/types";
import { otherSchemas as schemas } from "@condu/schema-types/utils/schemas.js";
import { mapValues } from "remeda";
import type { Conventions } from "@condu/types/configTypes.js";
import type {
  CollectedTask,
  Task,
} from "@condu/cli/commands/apply/CollectedState.js";
import type { GithubAction } from "@condu/schema-types/schemas/githubAction.gen.js";
import { getYamlParseAndStringify } from "@condu/cli/commands/apply/defaultParseAndStringify.js";

declare module "@condu/types/extendable.js" {
  interface FileNameToSerializedTypeMapping {
    ".github/actions/moon-ci-setup/action.yml": GithubAction;
    ".github/workflows/moon-ci.yml": GithubWorkflow;
    "moon.yml": MoonProject;
  }
}

export const moonCi = (opts: {} = {}) =>
  defineFeature("moonCi", {
    defineRecipe(condu, peerContext) {
      const config = condu.project.config;
      const packageManager = config.node.packageManager.name;
      condu.root.generateFile(".github/actions/moon-ci-setup/action.yml", {
        ...getYamlParseAndStringify<GithubAction>(),
        content: {
          name: "Moon CI Setup",
          description: "Setup the environment for Moon CI",
          inputs: {
            "registry-url": {
              description: "The NPM registry URL",
              required: false,
              default:
                config.publish?.registry ?? "https://registry.npmjs.org/",
            },
          },
          runs: {
            using: "composite",
            steps: [
              ...(packageManager !== "npm" && packageManager !== "bun"
                ? [{ run: `corepack enable`, shell: "bash" }]
                : []),
              {
                uses: "actions/setup-node@v4",
                with: {
                  "node-version-file": "package.json",
                  cache: packageManager === "bun" ? "" : packageManager,
                  "registry-url": "${{ inputs.registry-url }}",
                },
              },
              { uses: "oven-sh/setup-bun@v2" },
              {
                run: `${packageManager} ${
                  packageManager === "yarn"
                    ? "install --immutable"
                    : packageManager === "npm"
                      ? "ci"
                      : "install --frozen-lockfile"
                }`,
                shell: "bash",
              },
              {
                run: `./node_modules/.bin/moon ci :build`,
                shell: "bash",
                env: { MOON_TOOLCHAIN_FORCE_GLOBALS: "true" },
              },
            ],
          },
        },
      });

      condu.root.generateFile(".github/workflows/moon-ci.yml", {
        ...getYamlParseAndStringify<GithubWorkflow>(),
        content: {
          name: "Moon CI",
          on: {
            push: { branches: [config.git.defaultBranch] },
            pull_request: {},
          },
          env: {
            GIT_DEFAULT_BRANCH: "${{ github.event.repository.default_branch }}",
          },
          jobs: {
            ci: {
              name: "Moon CI",
              "runs-on": "ubuntu-latest",
              env: { MOON_TOOLCHAIN_FORCE_GLOBALS: "true" },
              steps: [
                {
                  uses: "actions/checkout@v4",
                  with: { "fetch-depth": 0 },
                },
                {
                  name: "Moon CI Setup",
                  uses: "./.github/actions/moon-ci-setup",
                },
                {
                  name: "Test",
                  run: `./node_modules/.bin/moon ci :test`,
                  shell: "bash",
                },
              ],
            },
          },
        },
      });

      condu.in({ kind: "package" }).generateFile("moon.yml", {
        ...getYamlParseAndStringify<MoonProject>(),
        content: ({ targetPackage, globalRegistry }) => {
          const tasksForPackage = Array.from(
            globalRegistry.getTasksMatchingPackage(targetPackage),
            (task) =>
              [getTaskName(task), task.taskDefinition.definition] as const,
          );
          const tasks = Object.fromEntries(tasksForPackage) as Record<
            string,
            MoonTask
          >;

          return {
            $schema: schemas.project,
            tasks,
          };
        },
      });

      // add in type-tasks:
      condu.root.generateFile("moon.yml", {
        ...getYamlParseAndStringify<MoonProject>(),
        content: ({ targetPackage, globalRegistry }) => {
          const tasksForPackage = Array.from(
            globalRegistry.getTasksMatchingPackage(targetPackage),
            (task) =>
              [
                task.taskDefinition.name,
                task.taskDefinition.definition,
              ] as const,
          );
          const tasks = Object.fromEntries(tasksForPackage) as Record<
            string,
            MoonTask
          >;

          return {
            $schema: schemas.project,
            tasks: {
              ...tasks,
              ...getWorkspaceTasks({
                tasks: globalRegistry.tasks,
                conventions: config.conventions,
              }),
            },
          };
        },
      });
    },
  });

type TasksByType = Record<Task["type"], CollectedTask[]>;

const builtinTaskNames = new Set<string>([
  "build",
  "test",
  "format",
  "publish",
  "start",
] satisfies Task["type"][]);

const getTaskName = (task: CollectedTask) =>
  builtinTaskNames.has(task.taskDefinition.name)
    ? `${task.targetPackage.scopedName}-${task.taskDefinition.name}`
    : task.taskDefinition.name;

function getWorkspaceTasks({
  tasks,
  conventions,
}: {
  tasks: readonly CollectedTask[];
  conventions: Required<Conventions>;
}): Record<string, MoonTask> {
  const tasksByType: TasksByType = {
    build: [],
    test: [],
    format: [],
    publish: [],
    start: [],
  };

  for (const task of tasks) {
    if (task.targetPackage.kind === "workspace") {
      continue;
    }
    tasksByType[task.taskDefinition.type].push(task);
  }

  const taskDefinitions = mapValues(
    tasksByType,
    (tasks, type): MoonTask => ({
      deps: tasks.map(
        (task) => `${task.targetPackage.name}:${getTaskName(task)}`,
      ),
      inputs: [],
      ...(type === "publish" && { options: { runDepsInParallel: false } }),
      ...(type === "format" && { options: { runInCI: false } }),
    }),
  );

  return {
    ...taskDefinitions,
    clean: {
      command: `rm -rf ${conventions.buildDir} .moon/cache/states`,
      options: { cache: false, runInCI: false },
    },
  };
}
```

# ./packages/features/condu-packages/conduPackages.ts

## before

```ts
import { defineFeature } from "condu/defineFeature.js";
import {
  CONDU_WORKSPACE_PACKAGE_NAME,
  CORE_NAME,
} from "@condu/types/constants.js";

export const conduPackages = (opts: {} = {}) =>
  defineFeature({
    name: "condu",
    actionFn: (config, state) => {
      const isInternalCondu =
        config.project.manifest.name === CONDU_WORKSPACE_PACKAGE_NAME;
      return {
        effects: [
          {
            tasks: [
              {
                type: "publish",
                name: "release",
                definition: {
                  command: `${
                    isInternalCondu
                      ? `${config.node.packageManager.name} run `
                      : ""
                  }${CORE_NAME} release`,
                },
              },
            ],
          },
        ],
      };
    },
  });
```

## after

```ts
import { defineFeature } from "condu/defineFeature.js";
import {
  CONDU_WORKSPACE_PACKAGE_NAME,
  CORE_NAME,
} from "@condu/types/constants.js";

export const conduPackages = (opts: {} = {}) =>
  defineFeature("condu-packages", {
    defineRecipe: (condu, peerContext) => {
      const isInternalCondu =
        condu.project.manifest.name === CONDU_WORKSPACE_PACKAGE_NAME;

      condu.root.defineTask("release", {
        type: "publish",
        definition: {
          command: `${
            isInternalCondu
              ? `${condu.project.config.node.packageManager.name} run `
              : ""
          }${CORE_NAME} release`,
        },
      });
    },
  });
```

---

# types.ts

## before

```ts
export type FeatureActionFn = (
  config: ConduConfigWithInferredValuesAndProject,
  state: CollectedState,
) => FeatureResult | Promise<FeatureResult | void> | void;

export interface FeatureResult {
  effects?: (Effects | null | undefined | false)[];
  flags?: ReadonlyArray<keyof StateFlags>;
  autolinkIgnore?: string[];
}

export interface FeatureDefinition {
  actionFn: FeatureActionFn;
  name: string;
  order?: {
    after?: Array<string>;
    priority?: "beginning" | "end";
  };
}

export type Effects = {
  /** these files will be created during execution */
  files?: ReadonlyArray<FileDef | false | undefined>;
  tasks?: ReadonlyArray<Task | false | undefined>;
  hooks?: Partial<Hooks>;

  /** we'll ensure these dependencies are installed during execution */
  devDependencies?: (string | DependencyDef)[];

  /** we'll ensure these dependency resolutions are applied */
  resolutions?: Record<string, string>;

  /**
   * ts-pattern for package.jsons that the state applies to. Defaults to workspace.
   * @default { kind: "workspace" }
   * */
  matchPackage?: Pattern.Pattern<WorkspacePackage> | Partial<WorkspacePackage>;
};

// file management types
export type FileContent = string | AnyObject | Array<object> | SymlinkTarget;

export interface FileDef {
  type?: "ephemeral" | "committed" | "ignore-only";
  alwaysOverwrite?: boolean;
  /** should this file be published when making a distributable package */
  publish?: boolean;
  content?:
    | FileContent
    | ((opts: {
        pkg: WorkspacePackage;
        getExistingContentAndMarkAsUserEditable: GetExistingContentFn;
      }) => Promise<FileContent> | FileContent);
  path: string;
}
```

## after

```ts
export type FeatureActionFn = <NameT extends keyof PeerContext>(
  name: NameT,
  definition: Omit<FeatureDefinitionInput<NameT>, "name">,
) => FeatureDefinition<NameT>;

export interface FeatureDefinition<NameT extends string> {
  name: NameT;
  after?: Array<string> | string;
  initialPeerContext?:
    | GetPeerContext<NameT>
    | ((
        project: ReadonlyConduProject,
      ) => GetPeerContext<NameT> | Promise<GetPeerContext<NameT>>);
  modifyPeerContexts?: (
    project: ReadonlyConduProject,
    initialPeerContext: GetPeerContext<NameT>,
  ) => Promise<PeerContextReducer> | PeerContextReducer;
  defineRecipe: (
    condu: ConduApi,
    peerContext: GetPeerContext<NameT>,
  ) => void | Promise<void>;
}

export interface ConduApi {
  readonly project: ConduProject;
  readonly root: StateDeclarationApi;
  readonly in: (criteria: MatchPackage) => StateDeclarationApi;
}

export interface StateDeclarationApi {
  ignoreFile(
    path: string,
    options?: Omit<PartialGlobalFileAttributes, "inAllPackages">,
  ): void;
  generateFile<PathT extends string>(
    path: PathT,
    options: GenerateFileOptionsForPath<PathT>,
  ): void;
  modifyGeneratedFile<PathT extends string>(
    path: PathT,
    options: ModifyGeneratedFileOptions<ResolvedSerializedType<PathT>>,
  ): void;
  modifyUserEditableFile<PathT extends string, DeserializedT>(
    path: PathT,
    options: ModifyUserEditableFileOptions<DeserializedT>,
  ): void;
  ensureDependency(name: string, dependency?: DependencyDefinitionInput): void;
  setDependencyResolutions(resolutions: Record<string, string>): void;
  modifyPackageJson(modifier: PackageJsonModifier): void;
  modifyPublishedPackageJson(modifier: PackageJsonModifier): void;
  defineTask(name: string, taskDefinition: Omit<Task, "name">): void;
}

export interface ConduProject extends IPackageEntry {
  readonly workspacePackages: readonly ConduPackageEntry<"package">[];
  readonly projectConventions: DefinedWorkspaceProjectConvention[] | undefined;
  readonly config: ConduConfigWithInferredValues;
  readonly allPackages: readonly ConduPackageEntry[];
}

// file-generation types
export interface WithGlobalFileAttributes {
  attributes?: PartialGlobalFileAttributes;
}

export interface GenerateSymlinkFileOptions
  extends WithGlobalFileAttributes,
    SymlinkTargetContent {
  /** defaults to 'error' */
  ifPreviouslyDefined?: IfPreviouslyDefined;
}

export interface GenerateFileOptions<DeserializedT>
  extends WithGlobalFileAttributes {
  content: InitialContent<DeserializedT>;

  /** defaults to stringify based on file extension */
  stringify?: (content: DeserializedT) => string;

  /** defaults to 'error' */
  ifPreviouslyDefined?: IfPreviouslyDefined;
}

export type IfNotCreated = "ignore" | "error" | "create";

export interface ContentModificationFunctionArgs<DeserializedT>
  extends ContentFunctionArgs {
  content: DeserializedT;
}

export interface ModifyGeneratedFileOptions<DeserializedT>
  extends WithGlobalFileAttributes {
  content: ({
    content,
    globalRegistry,
    targetPackage,
  }: ContentModificationFunctionArgs<DeserializedT>) =>
    | DeserializedT
    | Promise<DeserializedT>;
  // default is "ignore"
  ifNotCreated?: IfNotCreated;
  /** defaults to stringify based on file extension */
  stringify?: (content: DeserializedT) => string;
}

export interface ModifyUserEditableFileOptions<DeserializedT>
  extends WithGlobalFileAttributes {
  createIfNotExists?: boolean;
  content: ({
    content,
    globalRegistry,
    targetPackage,
  }: ContentModificationFunctionArgs<DeserializedT | undefined>) =>
    | DeserializedT
    | Promise<DeserializedT>;

  parse: (rawFileContent: string) => DeserializedT;
  stringify: (content: DeserializedT) => string;
}

// package management types
export type PackageJsonModifier = (
  pkg: ConduPackageJson,
) => ConduPackageJson | Promise<ConduPackageJson>;

export interface PackageJsonModification {
  modifier: PackageJsonModifier;
  context: CollectionContext;
}
export type PackageKind = "workspace" | "package";
export type WorkspaceRootPackage = ConduPackageEntry<"workspace">;
export type WorkspaceSubPackage = ConduPackageEntry<"package">;

export interface IPackageEntry<KindT extends PackageKind = PackageKind> {
  kind: KindT;
  /** shortcut to manifest.name */
  name: string;
  scope?: string | undefined;
  scopedName: string;
  manifest: ConduPackageJson;
  manifestRelPath: string;
  manifestAbsPath: string;
  /** relative directory of the package from the workspace path */
  relPath: string;
  /** absolute directory of the package */
  absPath: string;
}
```
