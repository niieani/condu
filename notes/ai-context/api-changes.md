# ./packages/features/editorconfig/editorconfig.ts

## before

```ts
import { defineFeature } from "condu/defineFeature.js";
import { serializeEditorConfig } from "./serialize.js";
import type { EditorConfig } from "./types.js";

const defaultConfig: EditorConfig = {
  root: true,
  sections: {
    "*": {
      indent_style: "space",
      indent_size: 2,
      end_of_line: "lf",
      charset: "utf-8",
      trim_trailing_whitespace: true,
      insert_final_newline: true,
      max_line_length: 80,
    },
  },
};

export const editorconfig = (config: EditorConfig = defaultConfig) =>
  defineFeature({
    name: "editorconfig",
    actionFn: (_config, state) => ({
      effects: [
        {
          files: [
            {
              path: ".editorconfig",
              content: serializeEditorConfig(config),
            },
          ],
        },
      ],
    }),
  });
```

## after

```ts
import { defineFeature } from "condu/defineFeature.js";
import { serializeEditorConfig } from "./serialize.js";
import type { EditorConfig, EditorConfigSection } from "./types.js";

const defaultConfig: EditorConfig = {
  root: true,
  sections: {
    "*": {
      indent_style: "space",
      indent_size: 2,
      end_of_line: "lf",
      charset: "utf-8",
      trim_trailing_whitespace: true,
      insert_final_newline: true,
      max_line_length: 80,
    },
  },
};

declare module "@condu/types/extendable.js" {
  interface PeerContext {
    editorconfig: {
      sections: Record<string, EditorConfigSection>;
    };
  }
  interface FileNameToSerializedTypeMapping {
    ".editorconfig": EditorConfig;
  }
}

export const editorconfig = (config?: EditorConfig) =>
  defineFeature("editorconfig", {
    initialPeerContext: {
      sections: config?.sections ?? defaultConfig.sections,
    },
    defineRecipe(condu, { sections }) {
      condu.root.generateFile(".editorconfig", {
        content: {
          ...defaultConfig,
          sections,
        },
        stringify: serializeEditorConfig,
      });
    },
  });
```

# ./packages/features/eslint/eslint.ts

## before

```ts
import { defineFeature } from "condu/defineFeature.js";
import { pick } from "remeda";
import type {
  ContextProvidedToEslintConfig,
  EslintFeatureInput,
} from "./types.js";
import path from "node:path";

const RUNNING_SOURCE_VERSION = import.meta.url.endsWith(".ts");

export const eslint = ({
  importAdditionalConfigFrom,
  defaultRules = {},
  ignores = [],
}: { importAdditionalConfigFrom?: string } & EslintFeatureInput = {}) =>
  defineFeature({
    name: "eslint",
    actionFn: (config, state) => {
      const needsTypeScript =
        RUNNING_SOURCE_VERSION || importAdditionalConfigFrom?.endsWith(".ts");
      return {
        autolinkIgnore: importAdditionalConfigFrom
          ? [importAdditionalConfigFrom]
          : [],
        effects: [
          {
            files: [
              {
                path: "eslint.config.js",
                content: () => {
                  const eslintContext: ContextProvidedToEslintConfig = {
                    ...pick(config, ["conventions", "projects"]),
                    ignores: [
                      ...state.files.map(({ path: p, targetDir }) =>
                        targetDir === "."
                          ? `${p}`
                          : `${targetDir}/${path.normalize(p)}`,
                      ),
                      ...ignores,
                    ],
                    defaultRules,
                  };
                  return `// note: this file was auto-generated by condu
// if you want to make changes, edit the .config/condu.ts file instead

import { getConfigs } from "@condu-feature/eslint/config.${
                    needsTypeScript ? "ts" : "js"
                  }";
${importAdditionalConfigFrom ? `import additionalConfigs from "./.config/${path.normalize(importAdditionalConfigFrom)}";` : ""}
const configs = getConfigs(${JSON.stringify(eslintContext, undefined, 2)}${importAdditionalConfigFrom ? ", additionalConfigs" : ""});
export default configs;\n`;
                },
              },
            ],
            devDependencies: [
              "eslint",
              "eslint-plugin-import-x",
              "eslint-plugin-unicorn",
              "eslint-import-resolver-typescript",
              "@eslint/js",
              "@typescript-eslint/parser",
              "@typescript-eslint/eslint-plugin",
              ...(needsTypeScript ? ["tsx"] : []),
            ],
            tasks: [
              {
                name: "eslint",
                type: "test",
                definition: {
                  command: "eslint",
                  inputs: ["@group(sources)"],
                  ...(needsTypeScript
                    ? {
                        // TODO: consider node strip types instead
                        env: { NODE_OPTIONS: "--import tsx/esm" },
                      }
                    : {}),
                },
              },
            ],
          },
        ],
      };
    },
  });
```

## after

```ts
import { defineFeature } from "condu/defineFeature.js";
import { pick } from "remeda";
import type {
  ContextProvidedToEslintConfig,
  EslintFeatureInput,
} from "./types.js";
import path from "node:path";
import { CONDU_CONFIG_DIR_NAME } from "@condu/types/constants.js";

const RUNNING_SOURCE_VERSION = import.meta.url.endsWith(".ts");

export interface EslintFeatureConfig extends EslintFeatureInput {
  importAdditionalConfigFrom?: string;
}

export interface EslintFeaturePeerContext extends Required<EslintFeatureInput> {
  importAdditionalConfigFrom?: string;
}

declare module "@condu/types/extendable.js" {
  interface PeerContext {
    eslint: EslintFeaturePeerContext;
  }
}

export const eslint = (config: EslintFeatureConfig = {}) =>
  defineFeature("eslint", {
    initialPeerContext: {
      ...config,
      defaultRules: config.defaultRules ?? {},
      ignores: config.ignores ?? [],
    },

    modifyPeerContexts: (project, initialPeerContext) => ({
      global: (current) => ({
        ...current,
        execWithTsSupport:
          RUNNING_SOURCE_VERSION ||
          initialPeerContext.importAdditionalConfigFrom?.endsWith(".ts") ||
          current.execWithTsSupport,
      }),
      vscode: (current) => ({
        ...current,
        suggestedSettings: {
          ...current.suggestedSettings,
          "eslint.lintTask.enable": true,
          "eslint.useESLintClass": true,
          "eslint.runtime": "node",
        },
        enforcedSettings: {
          ...current.enforcedSettings,
          ...(project.config.globalPeerContext.execWithTsSupport
            ? {
                "eslint.execArgv": [
                  "--import",
                  import.meta.resolve("tsx/esm").slice("file://".length),
                ],
              }
            : {}),
        },
      }),
    }),

    defineRecipe(condu, { defaultRules, ignores, importAdditionalConfigFrom }) {
      const execWithTsSupport =
        condu.project.config.globalPeerContext.execWithTsSupport;

      condu.root.generateFile("eslint.config.js", {
        content({ globalRegistry }) {
          const eslintContext: ContextProvidedToEslintConfig = {
            ...pick(condu.project.config, ["conventions", "projects"]),
            ignores: [
              ...globalRegistry.files.map(([filePath]) => filePath),
              ...ignores,
            ],
            defaultRules,
          };
          return /* ts */ `
// note: this file was auto-generated by condu
// if you want to make changes, edit the .config/condu.ts file instead

import { getConfigs } from "@condu-feature/eslint/config.${execWithTsSupport ? "ts" : "js"}";
${importAdditionalConfigFrom ? `import additionalConfigs from "./${CONDU_CONFIG_DIR_NAME}/${path.normalize(importAdditionalConfigFrom)}";` : ""}
const configs = getConfigs(${JSON.stringify(eslintContext, undefined, 2)}${importAdditionalConfigFrom ? ", additionalConfigs" : ""});
export default configs;
`.trimStart();
        },
      });

      condu.root.ensureDependency("eslint");
      condu.root.ensureDependency("eslint-plugin-import-x");
      condu.root.ensureDependency("eslint-plugin-unicorn");
      condu.root.ensureDependency("eslint-import-resolver-typescript");
      condu.root.ensureDependency("@eslint/js");
      condu.root.ensureDependency("@typescript-eslint/parser");
      condu.root.ensureDependency("@typescript-eslint/eslint-plugin");
      if (execWithTsSupport) {
        condu.root.ensureDependency("tsx");
      }

      condu.root.defineTask("eslint", {
        type: "test",
        definition: {
          command: "eslint",
          inputs: ["@group(sources)"],
          ...(execWithTsSupport
            ? // TODO: consider node strip types instead
              { env: { NODE_OPTIONS: "--import tsx/esm" } }
            : {}),
        },
      });
    },
  });
```

# ./packages/features/gitignore/gitignore.ts

## before

```ts
import { CONDU_CONFIG_DIR_NAME } from "@condu/types/constants.js";
import { defineFeature } from "condu/defineFeature.js";
import * as path from "node:path";
import { groupBy } from "remeda";

export const gitignore = ({ ignore = [] }: { ignore?: string[] } = {}) =>
  defineFeature({
    name: "gitignore",
    order: { priority: "end" },
    actionFn: (config, state) => ({
      effects: [
        {
          files: [
            {
              path: ".gitignore",
              content: () => {
                const filesByFeature = groupBy(
                  state.files.filter(
                    ({ type, skipIgnore }) =>
                      type !== "committed" && !skipIgnore,
                  ),
                  ({ featureName }) => featureName,
                );
                const entriesFromFeatures = Object.entries(
                  filesByFeature,
                ).flatMap(([featureName, files]) => {
                  if (featureName === "gitignore") return [];
                  return [
                    `# ${featureName}:`,
                    ...files.map(({ path: p, targetDir, type }) =>
                      type === "ignore-only"
                        ? p
                        : `/${path.join(targetDir, p)}`,
                    ),
                  ];
                });
                return (
                  [
                    ".DS_Store",
                    "node_modules",
                    `/${CONDU_CONFIG_DIR_NAME}/.cache/`,
                    `/${config.conventions.buildDir}/`,
                    // ignore all generated files:
                    ...entriesFromFeatures,
                    ...(ignore.length > 0 ? ["# custom ignore patterns:"] : []),
                    ...ignore,
                  ].join("\n") + "\n"
                );
              },
            },
          ],
        },
      ],
    }),
  });
```

## after

```ts
import { CONDU_CONFIG_DIR_NAME } from "@condu/types/constants.js";
import { defineFeature } from "condu/defineFeature.js";
import { groupBy } from "remeda";

export interface IgnoreConfig {
  ignore?: string[];
}

declare module "@condu/types/extendable.js" {
  interface PeerContext {
    gitignore: Required<IgnoreConfig>;
  }
  interface FileNameToSerializedTypeMapping {
    ".gitignore": Array<string>;
  }
  interface GlobalFileAttributes {
    gitignore: boolean;
  }
}

export const gitignore = (opts: IgnoreConfig = {}) =>
  defineFeature("gitignore", {
    initialPeerContext: { ignore: opts.ignore ?? [] },

    defineRecipe(condu, { ignore }) {
      condu.root.generateFile(".gitignore", {
        content({ globalRegistry }) {
          const files = globalRegistry.getFilesMatchingAttribute("gitignore", {
            includeUnflagged: true,
          });
          const filesByFeature = groupBy(
            [...files],
            ([_path, file]) =>
              file.managedByFeatures[0]?.featureName ?? "unmanaged",
          );
          const entriesFromFeatures = Object.entries(filesByFeature).flatMap(
            ([featureName, files]) => {
              if (featureName === "gitignore") return [];
              return [`# ${featureName}:`, ...files.map(([p]) => `/${p}`)];
            },
          );
          // TODO: option to group all inAllPackages files by adding a single non / prefixed entry for a cleaner output
          return [
            ".DS_Store",
            "node_modules",
            `/${CONDU_CONFIG_DIR_NAME}/.cache/`,
            `/${condu.project.config.conventions.buildDir}/`,
            // ignore all generated files:
            ...entriesFromFeatures,
            ...(ignore.length > 0 ? ["# custom ignore patterns:"] : []),
            ...ignore,
          ];
        },

        stringify(content) {
          return content.join("\n") + "\n";
        },
      });
    },
  });
```

# ./packages/features/vscode/vscode.ts

## before

```ts
import { defineFeature } from "condu/defineFeature.js";
import { assign } from "comment-json";
import type { VscodeSettingsWorkspace } from "@condu/schema-types/schemas/vscodeSettingsWorkspace.gen.js";
import * as path from "node:path";

const RUNNING_SOURCE_VERSION = import.meta.url.endsWith(".ts");

const defaultEnforcedConfig: VscodeSettingsWorkspace = {
  ...(RUNNING_SOURCE_VERSION
    ? {
        "eslint.execArgv": [
          "--import",
          import.meta.resolve("tsx/esm").slice("file://".length),
        ],
      }
    : {}),
};

const defaultSuggestedConfig: VscodeSettingsWorkspace = {
  // TODO: only add these eslint settings if the eslint feature is enabled
  "eslint.lintTask.enable": true,
  "eslint.useESLintClass": true,
  // forces vscode to run eslint with the node version installed in the system,
  // instead of the one bundled with vscode
  "eslint.runtime": "node",
  // "eslint.runtime": process.argv0,
  "typescript.tsserver.experimental.enableProjectDiagnostics": true,
  "typescript.tsdk": "node_modules/typescript/lib",
};

export const vscode = ({
  suggestedConfig = {},
  enforcedConfig = {},
  hideGeneratedFiles = false,
}: {
  hideGeneratedFiles?: boolean;
  suggestedConfig?: VscodeSettingsWorkspace;
  enforcedConfig?: VscodeSettingsWorkspace;
} = {}) =>
  defineFeature({
    name: "vscode",
    order: { priority: "end" },
    actionFn: async (config, state) => {
      // TODO: also, auto-add 'tasks.json' based on the defined tasks
      return {
        effects: [
          {
            files: [
              {
                path: ".vscode/settings.json",
                content: async ({
                  getExistingContentAndMarkAsUserEditable: getExistingContent,
                }) => {
                  const existingContent =
                    ((await getExistingContent()) as VscodeSettingsWorkspace) ??
                    {};
                  const excludedFiles = hideGeneratedFiles
                    ? Object.fromEntries(
                        state.files
                          .filter(
                            ({ type, skipIgnore, featureName }) =>
                              type !== "committed" &&
                              !skipIgnore &&
                              featureName !== "vscode",
                          )
                          .map(({ path: p, targetDir }) => [
                            // remove leading './' from path
                            path.normalize(path.join(targetDir, p)),
                            true,
                          ]),
                      )
                    : {};
                  const withEnforcedConfig = assign(existingContent, {
                    ...defaultEnforcedConfig,
                    ...enforcedConfig,
                    "files.exclude": {
                      ...excludedFiles,
                      ...enforcedConfig?.["files.exclude"],
                    },
                    "search.exclude": {
                      [config.conventions.buildDir]: true,
                    },
                  } satisfies VscodeSettingsWorkspace);
                  const suggestedConfigWithDefaults = {
                    ...defaultSuggestedConfig,
                    ...suggestedConfig,
                  };
                  return assign(
                    suggestedConfigWithDefaults,
                    withEnforcedConfig,
                  );
                },
              },
            ],
            devDependencies: RUNNING_SOURCE_VERSION ? ["tsx"] : [],
          },
        ],
      };
    },
  });
```

## after

```ts
import { defineFeature } from "condu/defineFeature.js";
import { assign } from "comment-json";
import type { VscodeSettingsWorkspace } from "@condu/schema-types/schemas/vscodeSettingsWorkspace.gen.js";
import { getYamlParseAndStringify } from "@condu/cli/commands/apply/defaultParseAndStringify.js";

const RUNNING_SOURCE_VERSION = import.meta.url.endsWith(".ts");

// TODO: move these to TypeScript feature:
const defaultSuggestedSettings: VscodeSettingsWorkspace = {
  "typescript.tsserver.experimental.enableProjectDiagnostics": true,
  "typescript.tsdk": "node_modules/typescript/lib",
};

declare module "@condu/types/extendable.js" {
  interface PeerContext {
    vscode: VSCodePeerContext;
  }
  interface GlobalFileAttributes {
    vscode: boolean;
  }
}

interface VSCodePeerContext {
  suggestedSettings: VscodeSettingsWorkspace;
  enforcedSettings: VscodeSettingsWorkspace;
}

interface VSCodeConfig extends Partial<VSCodePeerContext> {
  hideGeneratedFiles?: boolean;
}

export const vscode = ({
  hideGeneratedFiles = false,
  ...config
}: VSCodeConfig = {}) =>
  defineFeature("vscode", {
    initialPeerContext: {
      suggestedSettings: config.suggestedSettings ?? {},
      enforcedSettings: config.enforcedSettings ?? {},
    },

    modifyPeerContexts: () => ({
      global: (current) => ({
        ...current,
        execWithTsSupport: current.execWithTsSupport || RUNNING_SOURCE_VERSION,
      }),
    }),

    defineRecipe(condu, { suggestedSettings, enforcedSettings }) {
      condu.root.modifyUserEditableFile(".vscode/settings.json", {
        content({ content = {}, globalRegistry }) {
          const excludedFiles = [
            // TODO: potentially add a global 'alwaysVisibleInEditor' flag to indicate a file might not be hidden
            ...globalRegistry.getFilesMatchingAttribute("gitignore", {
              includeUnflagged: true,
            }),
          ].filter(
            ([_relPath, file]) =>
              !file.managedByFeatures.some(
                (context) => context.featureName === "vscode",
              ),
          );
          const withEnforcedConfig = assign(content, {
            ...enforcedSettings,
            "files.exclude": {
              ...(hideGeneratedFiles
                ? Object.fromEntries(
                    excludedFiles.map(([relPath]) => [relPath, true]),
                  )
                : {}),
              ...enforcedSettings?.["files.exclude"],
            },
            "search.exclude": {
              [condu.project.config.conventions.buildDir]: true,
              ...enforcedSettings?.["search.exclude"],
            },
          } satisfies VscodeSettingsWorkspace);
          const suggestedConfigWithDefaults = {
            ...defaultSuggestedSettings,
            ...suggestedSettings,
          };
          return assign(suggestedConfigWithDefaults, withEnforcedConfig);
        },
        ...getYamlParseAndStringify<VscodeSettingsWorkspace>(),
      });

      // TODO: also, auto-add 'tasks.json' based on the defined tasks
    },
  });
```

---

# types.ts

## before

```ts
export type FeatureActionFn = (
  config: ConduConfigWithInferredValuesAndProject,
  state: CollectedState,
) => FeatureResult | Promise<FeatureResult | void> | void;

export interface FeatureResult {
  effects?: (Effects | null | undefined | false)[];
  flags?: ReadonlyArray<keyof StateFlags>;
  autolinkIgnore?: string[];
}

export interface FeatureDefinition {
  actionFn: FeatureActionFn;
  name: string;
  order?: {
    after?: Array<string>;
    priority?: "beginning" | "end";
  };
}

export type Effects = {
  /** these files will be created during execution */
  files?: ReadonlyArray<FileDef | false | undefined>;
  tasks?: ReadonlyArray<Task | false | undefined>;
  hooks?: Partial<Hooks>;

  /** we'll ensure these dependencies are installed during execution */
  devDependencies?: (string | DependencyDef)[];

  /** we'll ensure these dependency resolutions are applied */
  resolutions?: Record<string, string>;

  /**
   * ts-pattern for package.jsons that the state applies to. Defaults to workspace.
   * @default { kind: "workspace" }
   * */
  matchPackage?: Pattern.Pattern<WorkspacePackage> | Partial<WorkspacePackage>;
};

// file management types
export type FileContent = string | AnyObject | Array<object> | SymlinkTarget;

export interface FileDef {
  type?: "ephemeral" | "committed" | "ignore-only";
  alwaysOverwrite?: boolean;
  /** should this file be published when making a distributable package */
  publish?: boolean;
  content?:
    | FileContent
    | ((opts: {
        pkg: WorkspacePackage;
        getExistingContentAndMarkAsUserEditable: GetExistingContentFn;
      }) => Promise<FileContent> | FileContent);
  path: string;
}
```

## after

```ts
export type FeatureActionFn = <NameT extends keyof PeerContext>(
  name: NameT,
  definition: Omit<FeatureDefinitionInput<NameT>, "name">,
) => FeatureDefinition<NameT>;

export interface FeatureDefinition<NameT extends string> {
  name: NameT;
  after?: Array<string> | string;
  initialPeerContext?:
    | GetPeerContext<NameT>
    | ((
        project: ReadonlyConduProject,
      ) => GetPeerContext<NameT> | Promise<GetPeerContext<NameT>>);
  modifyPeerContexts?: (
    project: ReadonlyConduProject,
    initialPeerContext: GetPeerContext<NameT>,
  ) => Promise<PeerContextReducer> | PeerContextReducer;
  defineRecipe: (
    condu: ConduApi,
    peerContext: GetPeerContext<NameT>,
  ) => void | Promise<void>;
}

export interface ConduApi {
  readonly project: ConduProject;
  readonly root: StateDeclarationApi;
  readonly in: (criteria: MatchPackage) => StateDeclarationApi;
}

export interface StateDeclarationApi {
  ignoreFile(
    path: string,
    options?: Omit<PartialGlobalFileAttributes, "inAllPackages">,
  ): void;
  generateFile<PathT extends string>(
    path: PathT,
    options: GenerateFileOptionsForPath<PathT>,
  ): void;
  modifyGeneratedFile<PathT extends string>(
    path: PathT,
    options: ModifyGeneratedFileOptions<ResolvedSerializedType<PathT>>,
  ): void;
  modifyUserEditableFile<PathT extends string, DeserializedT>(
    path: PathT,
    options: ModifyUserEditableFileOptions<DeserializedT>,
  ): void;
  ensureDependency(name: string, dependency?: DependencyDefinitionInput): void;
  setDependencyResolutions(resolutions: Record<string, string>): void;
  modifyPackageJson(modifier: PackageJsonModifier): void;
  modifyPublishedPackageJson(modifier: PackageJsonModifier): void;
  defineTask(name: string, taskDefinition: Omit<Task, "name">): void;
}

export interface ConduProject extends IPackageEntry {
  readonly workspacePackages: readonly ConduPackageEntry<"package">[];
  readonly projectConventions: DefinedWorkspaceProjectConvention[] | undefined;
  readonly config: ConduConfigWithInferredValues;
  readonly allPackages: readonly ConduPackageEntry[];
}

// file-generation types
export interface WithGlobalFileAttributes {
  attributes?: PartialGlobalFileAttributes;
}

export interface GenerateSymlinkFileOptions
  extends WithGlobalFileAttributes,
    SymlinkTargetContent {
  /** defaults to 'error' */
  ifPreviouslyDefined?: IfPreviouslyDefined;
}

export interface GenerateFileOptions<DeserializedT>
  extends WithGlobalFileAttributes {
  content: InitialContent<DeserializedT>;

  /** defaults to stringify based on file extension */
  stringify?: (content: DeserializedT) => string;

  /** defaults to 'error' */
  ifPreviouslyDefined?: IfPreviouslyDefined;
}

export type IfNotCreated = "ignore" | "error" | "create";

export interface ContentModificationFunctionArgs<DeserializedT>
  extends ContentFunctionArgs {
  content: DeserializedT;
}

export interface ModifyGeneratedFileOptions<DeserializedT>
  extends WithGlobalFileAttributes {
  content: ({
    content,
    globalRegistry,
    targetPackage,
  }: ContentModificationFunctionArgs<DeserializedT>) =>
    | DeserializedT
    | Promise<DeserializedT>;
  // default is "ignore"
  ifNotCreated?: IfNotCreated;
  /** defaults to stringify based on file extension */
  stringify?: (content: DeserializedT) => string;
}

export interface ModifyUserEditableFileOptions<DeserializedT>
  extends WithGlobalFileAttributes {
  createIfNotExists?: boolean;
  content: ({
    content,
    globalRegistry,
    targetPackage,
  }: ContentModificationFunctionArgs<DeserializedT | undefined>) =>
    | DeserializedT
    | Promise<DeserializedT>;

  parse: (rawFileContent: string) => DeserializedT;
  stringify: (content: DeserializedT) => string;
}

// package management types
export type PackageJsonModifier = (
  pkg: ConduPackageJson,
) => ConduPackageJson | Promise<ConduPackageJson>;

export interface PackageJsonModification {
  modifier: PackageJsonModifier;
  context: CollectionContext;
}
export type PackageKind = "workspace" | "package";
export type WorkspaceRootPackage = ConduPackageEntry<"workspace">;
export type WorkspaceSubPackage = ConduPackageEntry<"package">;

export interface IPackageEntry<KindT extends PackageKind = PackageKind> {
  kind: KindT;
  /** shortcut to manifest.name */
  name: string;
  scope?: string | undefined;
  scopedName: string;
  manifest: ConduPackageJson;
  manifestRelPath: string;
  manifestAbsPath: string;
  /** relative directory of the package from the workspace path */
  relPath: string;
  /** absolute directory of the package */
  absPath: string;
}
```
