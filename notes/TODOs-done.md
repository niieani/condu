## MVP / alpha TODO List

- [x] moonrepo integration
- [x] typescript
- [x] scaffolding new packages in monorepo (Create package command)
- [x] GitHub Actions
- [x] automatically add missing workspace dependencies to package.json
- [x] Individual Package overrides
- [x] yarn constraints
- [x] TS building for release - all files can be in the
  - prior art:
    - [tsconfig-to-dual-package](https://github.com/azu/tsconfig-to-dual-package#how-it-works)
    - [tsc-multi](https://github.com/tommy351/tsc-multi)
  - [x] make a script to copy all source files into the dist folder, except configs
  - [x] might need to settle for .cjs + .js for now if we want to use tsc --build for default esm build
    - this is also the future, since cjs is going away
  - [x] for main pass: simply build project with tsc
    - [x] post-build need to update .map files to have the correct paths, as sourceMappingURL is incorrect and needs to be corrected to use the adjecent .map file
  - [x] for other pass:
    - [x] build as ESM
    - [x] all the in-project references (relative or imports from existing monorepo ids) can be auto renamed to .mts
      - [x] make a list of all files as if imported using package name (e.g. '@thing/package/file.js')
      - [x] for each package, make additionally a list of all files
      - [x] for each file in each package, make a list of possible relative paths for other files (e.g. '../file.js')
      - [x] regexp replace all instances of the above with the '.mjs' extension
      - [x] since the extension is mandatory, failure is very unlikely. even if the filename is common, like './calc.js', it is unlikely this string would be used for anything other than an import from/export from
  - [x] adjust the "sources" in the .map files
  - [x] output will have: .ts, .js, .js.map, .d.ts, .mjs, .d.mts, .mjs.map + all other files
  - [x] solve source map references, still relative to the root, instead of always next to the file
  - [x] verify that `const x = <x>() => {}` works, because TS thinks it's a JSX tag, [which is supported in mts/cts by default](https://github.com/microsoft/TypeScript/issues/44442))
  - important [thread about this](https://github.com/microsoft/TypeScript/issues/49462)
- [x] figure out webpack merging / a custom config for this repo specifically?
- [x] added hooking for package.json generation, use it in the library feature to set the correct entry points
- [x] trim the "dependencies" in published package.json based on the config
- [x] auto-run 'apply' after package changes
- [x] pre-release
  - [x] copy/generate LICENSE to each package
  - [x] set correct package.json fields
    - [x] generate correct entry points (like https://github.com/isaacs/tshy)
    - [x] conventional entry point:
      - use `index.ts`, `main.ts` or `${packageName}.ts` if they exist (set camelCase or kebab-case in "conventions" - use it also for file name linting defaults)
- [x] vscode auto-ignore generated files
- [x] use https://www.npmjs.com/package/comment-json to keep the comments and only amend input if it exists
- [x] fully fleshed out build step on CI (incl. prepare dependency)
- [x] CI & semantic-release or [Auto](https://github.com/intuit/auto)
- [x] "clean"/"default" feature? before build, we need to run apply and clean 'build' dir
- [x] add a `condu` package that just wraps `@condu/cli` and adds the build script - this way @condu/cli can exist as its own package
  - [x] make sure the NPM token has permissions to publish both
- [x] fix "Unable to determine the default git branch"
- [x] support defining dependencies for features w/o importing from @condu/core
  - [x] extract that defineFunction into a separate package and keep it external? put it all in 'condu' along with the types? or does that create a circular dependency? maybe re-export the types from 'condu'
- [x] better support for making '@condu/core' a peerDependency
- [x] pnpm feature
- [x] local link/debug mode:
  - [x] link-other-monorepo feature: 'createOverrides' script to pnpm install 'build' as linked
- [x] why is the packageManager not getting set correctly for moon? moon feature seems to try to install yarn
- [x] mark which dependencies are managed by condu, and which are managed by the user (e.g. key in package.json: managedDependencies: { "name": "condu" })
- [x] when creating: don't add author, license by default, as they will be inherited from the workspace during publish, unless overwritten
- [x] fix generated license author
- [x] clean up of devDependencies that should be removed once a feature is removed/disabled
- [x] move to pnpm
- [x] in presets allow configurability/overrides? maybe passthrough all the config objects?
- [x] `condu init` command or a command that could be run with `npx condu init` to
  - [x] add a default config file
  - [x] add a script to package.json "postinstall": "test -f .config/condu.ts && condu apply"
  - [x] optionally create a new folder with git repo if `name` positional parameter is provided
  - [x] a preset package just exports an object, so applying a preset is just merging each of the properties
- [x] ensure `sourceDir` works with publishing
- [x] something is up with resolving
- [x] non-monorepo/single package mode
- [x] prettier
- [x] editorconfig
- [x] eslint customization / extension
  - [x] allow loading .config/eslint.ts (or specify custom filename?)
- [x] update release-please to use google version and update fork with https://github.com/googleapis/release-please-action/pull/1041
- [x] cache file needs to include condu version
- [x] vitest feature
- [x] CI build and test using moon
- [x] a way to ensure that certain dependencies/devDependencies/peerDependencies are set, or at least copy them over from template
- [x] re-evaluate the API for writing features - there's a lot of nesting, can it be simplified a bit?
  - also need a way to hook into each others features (i.e. modify behavior if other features are enabled)
  - maybe simply hooking into the outputted files (if they exist?), creating kind of a pipeline of file transformations?
- [x] fix imports so that the only thing you need to import from for features is 'condu'
- [x] correct `init` command's generated monorepo config (right now it generates invalid condu config)
- [x] why doesn't the correct TS project get loaded in .config/condu?
  - because all dotfiles are ignored and have to be explicitly included by typescript, by adding `.config/**/*` to includes
- [x] Add the ability to add simple way to define recipe-only features, using a shorthand, functional-style, e.g. `(condu) => condu.in({name: 'package'}).modifyPublishedPackageJson(...)`. These features would not have a name (they can attempt to read Function's `name` property if it exist, but default to a generated ID). Because of this, these features also not be involved in peerContext merging, etc., but otherwise would get applied the same regular features.
- [x] unlike `generateFile`'s content function, globalRegistry isn't available in PackageJsonModifier.
- [x] Create a new feature called 'package-scripts' that could be used instead of 'moon', in conjunction with a package manager (e.g. pnpm, yarn, npm or bun) to run the Tasks defined in features as package scripts. It should work both in single repo and monorepo contexts (but in a monorepo you'd expect the package manager to take the role of the script runner for all the scripts). The root-level scripts would use the package manager's feature to recursively run all scripts of a given kind/type, e.g. `pnpm -r run test`. You can see how moon is currently implemented in packages/features/moon/moon.ts. Currently CollectedState's `Task` type uses moonrepo's `PartialTaskConfig`, but we'll probably only support a subset of that type. See notes/tasks-config.ts for definition.
- [x] come up with a way to unit test applying features. like in the integration/basic.test.ts, we want to be able to load a feature (or multiple) with a given configuration, and test out what it writes. But we don't want it to be a full-on integration test, so it would have to perhaps run collectState (from packages/platform/condu/commands/apply/apply.ts) with a mock `project`, using 'mock-fs@5.5.0' to mock FS (based on the test's requirements), then run `await applyAndCommitCollectedState(collectedState)` and add snapshot tests on the new FS content. Write the test utilities in a new package under `packages/test/utils` and create a basic test for the `editorconfig` condu feature.
- [x] package-scripts feature should track which scripts are managed by condu. It should do it by storing managedScripts in the package.json's condu section (see similar `managedDependencies` section in packageJsonTypes.ts and how its used). This tracking should be used to remove scripts that are no longer managed. So for e.g. if I run condu apply and a vitest feature generates a script "test:vitest", and then I remove/disable the vitest feature and run `condu apply` again, the "test:vitest" script should be cleaned up.
- [x] when a symlink already exists and we say to overwrite it with file contents, it should remove the symlink first, otherwise for some reason it writes over the symlink target
- [x] Troubleshoot the integration test for the release command - release.test.ts. Reference other integration tests in test/integration/ and the release.ts file. We want it to create a mock project with some typescript files, and the typescript condu feature. We'll need a test for both a monorepo setup and a non-monorepo setup, and use the publish.registry config setting to make the publishing utilize the local veradiccio npm server (see `configTypes.ts` and `.condu/condu.ts`). The test shouldn't be running npm publish, as 'condu release' command will do that under the hood. The test shouldn't be changing any files in the build folder - this is condu's job, and that's what the test is testing! no need to create .npmrc, as the release command should set publish.registry in the `build` package.json's - this part is currently broken and we need the test to assert this and then start finding where the issue lies. We have full control over the NPM server, and when we start the server it's always a clean server without any packages published.
- [x] `condu release` should be okay with overwriting files
- [x] filtering by `kind: "package"` only works in monorepo, because in single repo mode the root package is still tracked as a "workspace"
- [x] gitignore needs to exclude files that are already in gitignore coming from autolink
- [x] extract 'generatedEntrySources' to a feature which autogenerates 'exports' in package.json - both for published and non-published packages
  - include adding a custom condition which is the name of the package, that points to the source ts
  - auto-map 'exports' in published/dist package.json - if only one file in directory, use that
