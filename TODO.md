MVP

- [x] moonrepo integration
- [x] typescript
- [x] typescript references
- [x] scaffolding new packages in monorepo (Create package command)
- [x] GitHub Actions
- [x] automatically add missing workspace dependencies to package.json
- [x] Individual Package overrides
- [x] yarn constraints
- [ ] TS building for release - all files can be in the
  - [x] make a script to copy all source files into the dist folder, except configs
  - [x] might need to settle for .cjs + .js for now if we want to use tsc --build for default esm build
    - this is also the future, since cjs is going away
  - [x] for main pass: simply build project with tsc
    - [ ] post-build need to update .map files to have the correct paths, as sourceMappingURL is incorrect and needs to be corrected to use the adjecent .map file
  - [x] for other pass:
    - [x] build as ESM
    - [x] all the in-project references (relative or imports from existing monorepo ids) can be auto renamed to .mts
      - [x] make a list of all files as if imported using package name (e.g. '@thing/package/file.js')
      - [x] for each package, make additionally a list of all files
      - [x] for each file in each package, make a list of possible relative paths for other files (e.g. '../file.js')
      - [x] regexp replace all instances of the above with the '.mjs' extension
      - [x] since the extension is mandatory, failure is very unlikely. even if the filename is common, like './calc.js', it is unlikely this string would be used for anything other than an import from/export from
  - [x] adjust the "sources" in the .map files
  - [x] output will have: .ts, .js, .js.map, .d.ts, .mjs, .d.mts, .mjs.map + all other files
  - [x] solve source map references, still relative to the root, instead of always next to the file
  - [ ] important [thread about this](https://github.com/microsoft/TypeScript/issues/49462)
  - [ ] verify that `const x = <x>() => {}` works, because TS thinks it's a JSX tag, [which is supported in mts/cts by default](https://github.com/microsoft/TypeScript/issues/44442))
- [ ] figure out webpack merging? or a custom config for this repo specifically?
  - yes, custom config is ok for now
- [ ] next step: added hooking for package.json generation, use it in the library feature to set the correct entry points
- [ ] trim the "dependencies" in published package.json based on the config
- [ ] should we collocate per-package build config in the respective packages, or keep them global?
  - [ ] if yes, then how do we do it? `.config` folder per package?
  - [ ] decision: where do we keep local config files? are they centrally managed? do we use config identifiers in folders names to nest configs?
- [ ] semantic-release (use [Auto](https://github.com/intuit/auto) instead for mono-repo support)
- [ ] look at whether we can have global tasks in moonrepo
- [ ] pre-release
  - [x] copy/generate LICENSE to each package
  - [x] set correct package.json fields
    - [x] generate correct entry points (like https://github.com/isaacs/tshy)
    - [x] conventional entry point:
      - use `index.ts`, `main.ts` or `${packageName}.ts` if they exist (set camelCase or kebab-case in "conventions" - use it also for file name linting defaults)
- [ ] add validation for feature dependencies (e.g. "auto" feature depends on "lerna")
  - maybe not dependencies, but see below - contributed state?
- [ ] add shared state for features (features can contribute to it and build on top of each other's state)
  - perhaps features contribute individual settings, like in vscode - providing a required schema - that way we could validate that the dependent state is valid
- [ ] vitest
- [ ] CI build and test using moon
- [ ] similar tool: https://packemon.dev/
- [ ] vscode auto-ignore generated files
- [x] use https://www.npmjs.com/package/comment-json to keep the comments and only amend input if it exists
- [ ] bare minimum for repo tool: just copy files from .config to the root and add them to .gitignore

- shippable state -

Later:

- [ ] multi-repo mode
  - best of both worlds - monorepo for development and keeping tools in sync, single-repo management benefits (separate issues, PRs, etc.)
  - orchestrate multiple repos with a parent configuration repo
  - support GitHub: automatically create a repo when creating a new package
    - [ ] autoconfigure repo based on settings (e.g. enable/disable wiki, issues, etc.)
      - either via package.json or repo.toml or something?
    - [ ] sync Github settings on apply-remote command? or something like that?
    - [ ] for CI: checkout the parent repo to run selected build/release?
    - [ ] option to automatically fetch all non-forked github repositories of a user?
  - could unify all of my repositories to make sure all of them are kept up-to-date
  - when cloning only a single repo, it needs to be able to bootstrap itself
    - maybe a command which will clone the parent repo (or use a global clone based on ENV variable) to make parent repo tooling available and generate config files only for that specific repo?
  - the managing repo doesn't contains submodules or list (for privacy)
  - more basic, but good references: https://manicli.com/project-background
- [ ] error reporting API for features
- [ ] transpile config files from .config to root
- [ ] unify/clarify naming around projects/workspaces/packages/workspace-root/etc
- [ ] allow setting default TypeScript extension: '.ts', '.cts', '.mts', '.js' (for building in TSDoc mode), as well as the default extension in imports: 'source' ('.ts') or 'output' ('.js')
- [ ] allow using one of the large scaffolds (epic-stack, electronforge, ignite red)
- [ ] for library-bundle:
  - [ ] option to bundle node_modules or not (with exceptions)
  - [ ] automatically remove the bundled modules from the built package.json, and maybe add them to optionalPeerDependencies?
  - [ ] perhaps the bundled package is published separately? e.g. under a package.bundle name? maybe this is overridable?
  - [ ] consider code-splitting by CLI command, to make the initial load faster?
- [ ] explain why it's better to ship unbundled - all transpiled files individually - and when bundling actually can make sense (e.g. for applications - CLI, etc.)
- [ ] 2 modes for running TypeScript that you could toggle between - with workspace references, or single-project
  - small projects don't need the overhead/downsides of workspace references
- [ ] [rollup-plugin-ts](https://github.com/wessberg/rollup-plugin-ts) ?
  - [ ] although, see discussion [here](https://github.com/microsoft/TypeScript/issues/4433), apparently it doesn't support declaration maps for now
- [ ] allow CJS building via SWC (automatically polyfills a bunch of things, and warns on top level await)
- [ ] when running `apply`, cli should clear previously generated files that are no longer needed
- [ ] should there be 2 default modes for TS? one targetting a more relaxed environment (apps), one targetting more strict ESM?
- [ ] clean-up empty directories left after deleting unused configs
- [ ] will Deno work with the ESM output out of the box?
- [ ] what if package jsons were also autogenerated? see [bit](https://blog.bitsrc.io/how-to-easily-manage-dependencies-in-a-js-monorepo-6216bd6621ea)
- [ ] jest
- [ ] Customizable package source directory (so we can skip src in mono repo), when publishing copy src into the publish directory. Hmm will semantic publishing work if we copy sources?
- [ ] State file to track changes made to the repo by the tool, and show diff before applying (for upgrading)
- [ ] Migration tool - should remove files from gitignore from committed files
- [ ] Docs: Great collection of [CLI websites](https://news.ycombinator.com/item?id=26878936) on HN
- [ ] TS: add a pure JavaScript with TSDoc mode
- [ ] adding arbitrary github action files from config (which means generating them from code is possible)
- [ ] config file - store local overrides diffing
  - i.e. if you manually change a YAML/JSON config file, we store the diff in .config, and then when we regenerate the config, we apply the diff on top of it
- [ ] move `@repo/core` dependency listing in features to peerDependencies
- [ ] create package.json's automatically on apply if they don't exist, then run yarn!
- [ ] website
- [ ] Product Hunt release
- [ ] to get good quality TS errors for both .cjs and .mjs, a wild idea would be to just dump the generated .cts files for build, and then remove them after build. maybe this could be done in the memoryFS that's overlaid on top of the real FS, where we use memFS only for the project directory, and the rest is real FS? or better yet, exclude from real FS specifically all the renamed files only. Mocked FS and we just run real `tsc --build` inside of it?
- [ ] write a generic TS helper for records/maps that contain arrays, it's a pain to always have to initialize them. or maybe have an initializer getOrSet or push/add() helper that pre-initializes it for you?
